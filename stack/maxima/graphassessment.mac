/* This file contains a library of code to help assess students' free-hand graph sketches. */
/* Based on work by Alexander Meyer and Tobias Mai, 2020.                                  */

/* For examples see: \doc\content\2018-proceedings\mai_tobias_2019_2582427.pdf             */

/* A student's graph comes to Maxima as a "list of points".
   This code deals with "lists of points".  

   To keep our input/output code as short as possible we use the function "pt" to represent a point.   
 
   So, a student's graph might be something like
   ans1:[pt(0,0), pt(0.5,0.25), pt(1,2), pt(2,4)];
*/

pttex(ex) := sconcat("\\left(", simplode(maplist(lambda([ex1], stack_disp_strip_dollars(tex(ex1, false))), args(ex)), ", "), "\\right)");
texput(pt, pttex);


/*Question Variables*/

f(x): -x^2+2*x+3;
LeftLimitOfInterval: -1;
RightLimitOfInterval: 3;

/* Node 1 - Feedback Applet*/



/* Node 2 - Are there enough points for an assessment?*/
adequate_number_of_points_p(ans, num):= is(length(ans)>=num)$

/*Node 3 - Does the sketch cover the whole interval -1<=x<=3?*/

/* 

Make sure the list ans1, has an adequate number of points in the interval ia <= x <= ib, by dividing this into ni regions.
That is, each interval should contain mpt points at least.

*/
adequate_distribution_of_points_p(ans, ia, ib, ni, mpt) := block([si, k, retall],
  /* Create ni evenly spaced points between ia and ib. */
  si:ev(makelist(ia+k*(ib-ia)/ni,k,0,ni), simp),
  if debug then print(si),
  /* retall is a variable to hold the answer. */
  retall:true,
  for k: 1 thru ni do 
   retall: (retall and is(length(sublist_indices(ans, lambda([ex], ev(is(si[k]<= ex and ex<si[k+1]), simp))))>= mpt)),
  return(retall)
)$


/* New Feedback Variables. */

/*Dividing -1<=x<=3 in 4 sections: (1) -1<=x<0, (2) 0<=x<1, (3) 1<=x<2, (4) 2<=x<=3*/
AdequateNumberOfPointsInEachSection: adequate_distribution_of_points_p(ans1, -1, 3, 4, 3);


/*Node 4+5 - Assessment of the sketch's accuracy*/ 
/*Determining (approximately) the lowest distance of each sketched Point to the function's graph in the intervall ia <= x <= ib in steps of ri.*/
/*IDEA OF VERSION FOR TWO INPUTS:*/
accurate_sketch_p(ansx, ansy, ia, ib, ri, tacc) := block([md, k, sacc, compare_tacc_sacc],
    
    /*create list (md) of every point's shortest distence to the function's graph*/
    md:[],
    for k:1 thru length(ansx) do 
    md: endcons(lmin(makelist(sqrt((ansx[k]-x)^2+(ansy[k]-(-x^2+2*x+3))^2), x, ia, ib, ri)), md),
    /*if debug then print(md),*/
    
    /*Calculating the sektch's average of the shortest distances (sacc)*/
    sacc: (lsum(k , k, md))/(length(ansx)),
    if debug then print(sacc),
    
    /*Compare sacc to the teacher's demanded accuracy (tacc)*/
    compare_tacc_sacc: is(sacc <= tacc),
    return(compare_tacc_sacc)
)$ 


/*
/*IDEA OF VERSION FOR ONLY ONE INPUT:*/
accurate_sketch_p(ans, ia, ib, ri, tacc) := block([md, k, sacc, compare_tacc_sacc],
    
    /*create list (md) of every point's shortest distence to the function's graph*/
    md:[],
    for k:1 thru length(ans) do 
    md: endcons(lmin(makelist(sqrt((ans[k][1]-x)^2+(ans[k][2]-(-x^2+2*x+3))^2), x, ia, ib, ri)), md),
    /*if debug then print(md),*/
    
    /*Calculating the sektch's average of the shortest distances (sacc)*/
    sacc: (lsum(k , k, md))/(length(ans)),
    if debug then print(sacc),
    
    /*Compare sacc to the teacher's demanded accuracy (tacc)*/
    compare_tacc_sacc: is(sacc <= tacc),
    return(compare_tacc_sacc)
)$ 
*/

/*Examples:
accurate_sketch_p(ans1, ans2, -1, 3, 0.01, 0.22);
accurate_sketch_p(ans3, ans4, -1, 3, 0.01, 0.22);
accurate_sketch_p(ans5, ans6, -1, 3, 0.01, 0.22);
accurate_sketch_p(ans5, ans6, -1, 3, 0.01, 0.15);*/



/*Node 6 - Does the sketch contain the function's x-intercepts and/or extrema? (Looking for points within a <0.2 radius around x-intercepts and extrema)*/

/*x-intercepts at x=(-1) (In the following variables this point is called XA)*/
ListOfDistancesFromAllPointsToXA: [];
LoopForDistancesToXA: for a:1 thru NumberOfSketchedPoints do ListOfDistancesFromAllPointsToXA: endcons(sqrt((ans1[a]-(-1))^2+(ans2[a]-(0))^2), ListOfDistancesFromAllPointsToXA);
PointsWithinTheRadiusAroundXA: sublist_indices(ListOfDistancesFromAllPointsToXA, lambda ([i], i<0.2));
SketchDepictsXA: is(length(PointsWithinTheRadiusAroundXA)>0);

/*x-intercepts at x=3  (In the following variables this point is called XB)*/
ListOfDistancesFromAllPointsToXB: [];
LoopForDistancesToXB: for a:1 thru NumberOfSketchedPoints do ListOfDistancesFromAllPointsToXB: endcons(sqrt((ans1[a]-(3))^2+(ans2[a]-(0))^2), ListOfDistancesFromAllPointsToXB);
PointsWithinTheRadiusAroundXB: sublist_indices(ListOfDistancesFromAllPointsToXB, lambda ([i], i<0.2));
SketchDepictsXB: is(length(PointsWithinTheRadiusAroundXB)>0);

/*Extremum at x=1  (In the following variables this point is called E)*/
ListOfDistancesFromAllPointsToE: [];
LoopForDistancesToE: for a:1 thru NumberOfSketchedPoints do ListOfDistancesFromAllPointsToE: endcons(sqrt((ans1[a]-(1))^2+(ans2[a]-(4))^2), ListOfDistancesFromAllPointsToE);
PointsWithinTheRadiusAroundE: sublist_indices(ListOfDistancesFromAllPointsToE, lambda ([i], i<0.2));
SketchDepictsE: is(length(PointsWithinTheRadiusAroundE)>0);

/*Assessment of all three points together*/
SketchDepictsAllImportantPoints: is(SketchDepictsXA=true) and is(SketchDepictsXB=true) and is(SketchDepictsE=true);

/*Generated Feedback if XA, XB and/or E is not depicted:  (Probably unnecessary in future forms of this task)*/
FeedbackLoopXA: (if(SketchDepictsXA=true) then "" else "Either you did not sketch the x-intercept at \\(x=(-1)\\) or your depiction is not accurate enough.");
FeedbackLoopXB: (if(SketchDepictsXB=true) then "" else "Either you did not sketch the x-intercept at \\(x=3\\) or your depiction is not accurate enough.");
FeedbackLoopE: (if(SketchDepictsE=true) then "" else "Either you did not sketch the extremum at \\(P(1|4)\\) or your depiction is not accurate enough.");



/*Node 7 - Is there a (too) high amount of points that are not in the interval ia<=x<=ib?*/


disregard_for_interval_p(ans, ia, ib) := is((length(sublist_indices(ans, lambda ([ex], ex<ia)))+length(sublist_indices(ans, lambda ([ex], ex>ib))))<=10);



/*Node 8+9 - Does the sketch contain (too) many runaway-points with (too) high distances to the function's graph?*/

/*Node 8*/
/*td is the variable for the teacher's demanded maximal distance to define runaway-points. dpt is the variable for maximal number of runaway-points accepted by the teacher. */
/*IDEA OF VERSION FOR TWO INPUTS:*/
searching_for_runaways_p(ansx, ansy, ia, ib, ri, td, dpt) := block([md, k, retall],
    
    /*create list (md) of every point's shortest distence to the function's graph*/
    md:[],
    for k:1 thru length(ansx) do 
    md: endcons(lmin(makelist(sqrt((ansx[k]-x)^2+(ansy[k]-(-x^2+2*x+3))^2), x, ia, ib, ri)), md),
    /*if debug then print(length(md)),*/
    
    /* retall is a variable to hold the answer. */
    retall:true,
    for k: 1 thru length(ansx) do 
    retall: (retall and is(length(sublist_indices(md, lambda([ex], ex>=td)))<=dpt)),
    if debug then print(length(sublist_indices(md, lambda([ex], ex>=td)))),
    return(retall)
)$


/*
/*IDEA OF VERSION FOR ONLY ONE INPUT:*/
searching_for_runaways_p(ans, ia, ib, ri, td, dpt) := block([md, k, retall],
    
    /*create list (md) of every point's shortest distence to the function's graph*/
    md:[],
    for k:1 thru length(ans) do 
    md: endcons(lmin(makelist(sqrt((ans[k][1]-x)^2+(ans[k][2]-(-x^2+2*x+3))^2), x, ia, ib, ri)), md),
    /*if debug then print(length(md)),*/
    
    /* retall is a variable to hold the answer. */
    retall:true,
    for k: 1 thru length(ans) do 
    retall: (retall and is(length(sublist_indices(md, lambda([ex], ex>=td)))<=dpt)),
    /*if debug then print(sublist_indices(md, lambda([ex], ex>=td))),*/
    if debug then print(length(sublist_indices(md, lambda([ex], ex>=td)))),
    return(retall)
)$
*/


/*Node 9 to follow*/