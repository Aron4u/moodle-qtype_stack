/* This file contains a library of code to help assess students' free-hand graph sketches. */
/* Based on work by Alexander Meyer and Tobias Mai, 2020.                                  */

/* For examples see: \doc\content\2018-proceedings\mai_tobias_2019_2582427.pdf             */

/* A student's graph comes to Maxima as a "list of points".
   This code deals with "lists of points".  

   To keep our input/output code as short as possible we use the function "pt" to represent a point.   
 
   So, a student's graph might be something like
   ans1:[pt(0,0), pt(0.5,0.25), pt(1,2), pt(2,4)];
*/

pttex(ex) := sconcat("\\left(", simplode(maplist(lambda([ex1], stack_disp_strip_dollars(tex(ex1, false))), args(ex)), ", "), "\\right)");
texput(pt, pttex);


/*Question Variables*/

f(x): -x^2+2*x+3;
LeftLimitOfInterval: -1;
RightLimitOfInterval: 3;

/* Node 1 - Feedback Applet*/



/* Node 2 - Are there enough points for an assessment?*/
adequate_number_of_points_p(ans, num):= is(length(ans)>=num)$

/*Node 3 - Does the sketch cover the whole interval -1<=x<=3?*/

/* 

Make sure the list ans1, has an adequate number of points in the interval ia <= x <= ib, by dividing this into ni regions.
That is, each interval should contain mpt points at least.

*/
adequate_distribution_of_points_p(ans, ia, ib, ni, mpt) := block([si, k, retall],
  /* Create ni evenly spaced points between ia and ib. */
  si:ev(makelist(ia+k*(ib-ia)/ni,k,0,ni), simp),
  if debug then print(si),
  /* retall is a variable to hold the answer. */
  retall:true,
  for k: 1 thru ni do 
   retall: (retall and is(length(sublist_indices(ans, lambda([ex], ev(is(si[k]<= ex and ex<si[k+1]), simp))))>= mpt)),
  return(retall)
)$


/* New Feedback Variables. */

/*Dividing -1<=x<=3 in 4 sections: (1) -1<=x<0, (2) 0<=x<1, (3) 1<=x<2, (4) 2<=x<=3*/
AdequateNumberOfPointsInEachSection: adequate_distribution_of_points_p(ans1, -1, 3, 4, 3);


/*Node 4+5 - Assessment of the sketche's accuracy by determining the lowest distance of each sketched Point to the function's graph (approximately)*/

ListOfMinimalDistances: [];
LoopForMinimalDistances: for i:1 thru NumberOfSketchedPoints do ListOfMinimalDistances: endcons(lmin(makelist(sqrt((ans1[i]-x)^2+(ans2[i]-(-x^2+2*x+3))^2), x, -1, 3, 0.01)), ListOfMinimalDistances);

SumOfAllMinimalDistances: 0;
LoopForSum: for i:1 thru NumberOfSketchedPoints do SumOfAllMinimalDistances: SumOfAllMinimalDistances+ListOfMinimalDistances[i];

AverageOfMinimalDistances: SumOfAllMinimalDistances/NumberOfSketchedPoints;

/*Node 4*/
TolerableButImprovableAccuracy: is(AverageOfMinimalDistances<=0.22);

/*Node 5*/
GoodAccuracy: is(AverageOfMinimalDistances<=0.15);



/*Node 6 - Does the sketch contain the function's x-intercepts and/or extrema? (Looking for points within a <0.2 radius around x-intercepts and extrema)*/

/*x-intercepts at x=(-1) (In the following variables this point is called XA)*/
ListOfDistancesFromAllPointsToXA: [];
LoopForDistancesToXA: for a:1 thru NumberOfSketchedPoints do ListOfDistancesFromAllPointsToXA: endcons(sqrt((ans1[a]-(-1))^2+(ans2[a]-(0))^2), ListOfDistancesFromAllPointsToXA);
PointsWithinTheRadiusAroundXA: sublist_indices(ListOfDistancesFromAllPointsToXA, lambda ([i], i<0.2));
SketchDepictsXA: is(length(PointsWithinTheRadiusAroundXA)>0);

/*x-intercepts at x=3  (In the following variables this point is called XB)*/
ListOfDistancesFromAllPointsToXB: [];
LoopForDistancesToXB: for a:1 thru NumberOfSketchedPoints do ListOfDistancesFromAllPointsToXB: endcons(sqrt((ans1[a]-(3))^2+(ans2[a]-(0))^2), ListOfDistancesFromAllPointsToXB);
PointsWithinTheRadiusAroundXB: sublist_indices(ListOfDistancesFromAllPointsToXB, lambda ([i], i<0.2));
SketchDepictsXB: is(length(PointsWithinTheRadiusAroundXB)>0);

/*Extremum at x=1  (In the following variables this point is called E)*/
ListOfDistancesFromAllPointsToE: [];
LoopForDistancesToE: for a:1 thru NumberOfSketchedPoints do ListOfDistancesFromAllPointsToE: endcons(sqrt((ans1[a]-(1))^2+(ans2[a]-(4))^2), ListOfDistancesFromAllPointsToE);
PointsWithinTheRadiusAroundE: sublist_indices(ListOfDistancesFromAllPointsToE, lambda ([i], i<0.2));
SketchDepictsE: is(length(PointsWithinTheRadiusAroundE)>0);

/*Assessment of all three points together*/
SketchDepictsAllImportantPoints: is(SketchDepictsXA=true) and is(SketchDepictsXB=true) and is(SketchDepictsE=true);

/*Generated Feedback if XA, XB and/or E is not depicted:  (Probably unnecessary in future forms of this task)*/
FeedbackLoopXA: (if(SketchDepictsXA=true) then "" else "Either you did not sketch the x-intercept at \\(x=(-1)\\) or your depiction is not accurate enough.");
FeedbackLoopXB: (if(SketchDepictsXB=true) then "" else "Either you did not sketch the x-intercept at \\(x=3\\) or your depiction is not accurate enough.");
FeedbackLoopE: (if(SketchDepictsE=true) then "" else "Either you did not sketch the extremum at \\(P(1|4)\\) or your depiction is not accurate enough.");



/*Node 7 - Is there a (too) high amount of points that are not in the interval -1<=x<=3?*/

NumberOfPointsOnTheLeftSideOfTheInterval: length(PointsWithXValuesSmallerMinusOne);
PointsWithXValuesAboveThree: sublist_indices(ans1, lambda ([i], i>3));
NumberOfPointsOnTheRightSideOfTheInterval: length(PointsWithXValuesAboveThree);
NumberOfAllPointsOutsideTheInterval: NumberOfPointsOnTheLeftSideOfTheInterval+NumberOfPointsOnTheRightSideOfTheInterval;
NumberOfAllPointsOutsideTheIntervalIsTolerable: is(NumberOfAllPointsOutsideTheInterval<11);



/*Node 8+9 - Does the sketch contain (too) many runawaypoints with (too) high distances to the function's graph?*/

/*Node 8 - distance too high*/	
PointsWithTooHighDistances: sublist_indices(ListOfMinimalDistances, lambda ([i], i>0.3));
NumberOfPointsWithTooHighDistances: length(PointsWithTooHighDistances);
AcceptableAmountOfPointsWithTooHighDistances: is(NumberOfPointsWithTooHighDistances<10);

/*Node 9 - distance tolerable*/	
PointsWithTolerableDistances: sublist_indices(ListOfMinimalDistances, lambda ([i], i>0.2 and i<=0.3));
NumberOfPointsWithTolerableDistances: length(PointsWithTolerableDistances);
AcceptableAmountOfPointsWithTolerableDistances: is(NumberOfPointsWithTolerableDistances<10);	