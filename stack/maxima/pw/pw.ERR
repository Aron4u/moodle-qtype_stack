
/* Maxima error log from tests in pw.mac */

/* Problem 1 (line 12) */
put('pw,6.5,'version);
/* Erroneous Result?:
6.5 */ 
/* Expected result: */
put('pw,"Richard Hennessy",'author);

/* Problem 2 (line 14) */
put('pw,"rtest_pw.mac",'test_suite);
/* Erroneous Result?:
"rtest_pw.mac" */ 
/* Expected result: */
put('pw,"Copyright - Richard Hennessy, 2008-2012",'copyright);

/* Problem 3 (line 26) */
pwinfo([_package]):=block(disp("package name: pw.mac (c)"),
       disp("author: Richard V. Hennessy"),disp("revision: 6.5"),
       disp("Test suite : rtest_pw.mac"),
       disp("Recommended location: share/contrib"),
       disp("last update: June, 2012"),disp(""));
/* Erroneous Result?:
pwinfo([_package]):=block(disp("package name: pw.mac (c)"),
       disp("author: Richard V. Hennessy"),disp("revision: 6.5"),
       disp("Test suite : rtest_pw.mac"),
       disp("Recommended location: share/contrib"),
       disp("last update: June, 2012"),disp("")) */ 
/* Expected result: */
(load("opsubst"),load("unwind_protect"),load("simplifying.lisp"),
 load("abs_integrate.mac"));

/* Problem 4 (line 56) */
simp_given(__e,[__fcts])::=buildq([__e,__fcts],
           block([_fct,_otherfacts:facts()],
                 unwind_protect((apply(assume,__fcts),expand(__e,0,0)),
                                for _fct in facts() do
                                    if not member(_fct,_otherfacts)
                                        then apply('forget,['_fct]))));
/* Erroneous Result?:
simp_given(__e,[__fcts])::=buildq([__e,__fcts],
           block([_fct,_otherfacts:facts()],
                 unwind_protect((apply(assume,__fcts),expand(__e,0,0)),
                                for _fct in facts() do
                                    if not member(_fct,_otherfacts)
                                        then apply('forget,['_fct])))) */ 
/* Expected result: */
_usepwdelta:false;

/* Problem 5 (line 59) */
global:true,global = true;
/* Erroneous Result?:
true */ 
/* Expected result: */
use_between:false;

/* Problem 6 (line 63) */
gradef(unit_step(__x),0);
/* Erroneous Result?:
unit_step(__x) */ 
/* Expected result: */
gradef(signum(__x),0);

/* Problem 7 (line 65) */
gradef(unit_spike(__x),0);
/* Erroneous Result?:
unit_spike(__x) */ 
/* Expected result: */
gradef(abs(x),signum(x));

/* Problem 8 (line 67) */
gradef(between(__x,__a,__b,__c),0,und,und,und);
/* Erroneous Result?:
between(__x,__a,__b,__c) */ 
/* Expected result: */
gradef(unit_pulse(__x),0);

/* Problem 9 (line 92) */
gen_deltas([_v]):=block(
           if listp(_v) and not emptyp(_v) and is(first(_v) = false)
               then (_usepwdelta:false,gradef(unit_step(__x),0),
                     gradef(signum(__x),0),gradef(unit_pulse(__x),0),
                     gradef(between(__x,__a,__b,__c),0,und,und))
               elseif listp(_v) and not emptyp(_v) and is(first(_v) = true)
               then (_usepwdelta:true,gradef(unit_step(__x),pwdelta(__x)),
                     gradef(signum(__x),2*pwdelta(__x)),
                     gradef(unit_pulse(__x),pwdelta(__x)-pwdelta(__x-1)),
                     gradef(between(__x,__a,__b,__c),
                            ((1-unit_spike(__b-__a)+signum(__b-__a))
                             *(pwdelta(__x-__a)-pwdelta(__x-__b)))
                             /2,und,und,und)),
           if _usepwdelta then "pwdeltas() will be used"
               else "no pwdeltas() will be used"),_usepwdelta = false;
/* Erroneous Result?:
gen_deltas([_v]):=block(
           if listp(_v) and not emptyp(_v) and is(first(_v) = false)
               then (_usepwdelta:false,gradef(unit_step(__x),0),
                     gradef(signum(__x),0),gradef(unit_pulse(__x),0),
                     gradef(between(__x,__a,__b,__c),0,und,und))
               elseif listp(_v) and not emptyp(_v) and is(first(_v) = true)
               then (_usepwdelta:true,gradef(unit_step(__x),pwdelta(__x)),
                     gradef(signum(__x),2*pwdelta(__x)),
                     gradef(unit_pulse(__x),pwdelta(__x)-pwdelta(__x-1)),
                     gradef(between(__x,__a,__b,__c),
                            ((1-unit_spike(__b-__a)+signum(__b-__a))
                             *(pwdelta(__x-__a)-pwdelta(__x-__b)))
                             /2,und,und,und)),
           if _usepwdelta then "pwdeltas() will be used"
               else "no pwdeltas() will be used") */ 
/* Expected result: */
_useabsint:true;

/* Problem 10 (line 96) */
_eim:copy(extra_integration_methods),_eim = [intfudu,intfugudu,signum_int,abs_integrate_use_if,floor_int,if_int],extra_integration_methods = [intfudu,intfugudu,signum_int,
                             abs_integrate_use_if,floor_int,if_int];
/* Erroneous Result?:
[intfudu,intfugudu,signum_int,abs_integrate_use_if,floor_int,if_int] */ 
/* Expected result: */
_edim:copy(extra_definite_integration_methods);

/* Problem 11 (line 117) */
use_absint([_v]):=block(
           if listp(_v) and not emptyp(_v) and is(first(_v) = false)
               then (extra_integration_methods:[],
                     extra_definite_integration_methods:[],_useabsint:false)
               elseif listp(_v) and not emptyp(_v) and is(first(_v) = true)
               then (extra_integration_methods:copy(_eim),
                     extra_definite_integration_methods:copy(_edim),
                     _useabsint:true),
           if _useabsint
               then "additional integration methods from abs_integrate.mac will be used"
               else "additional integration methods from abs_integrate.mac will not be used"),extra_integration_methods = [intfudu,intfugudu,signum_int,
                             abs_integrate_use_if,floor_int,if_int],extra_definite_integration_methods = [abs_defint],_useabsint = true,_eim = [intfudu,intfugudu,signum_int,abs_integrate_use_if,floor_int,if_int],_edim = [abs_defint];
/* Erroneous Result?:
use_absint([_v]):=block(
           if listp(_v) and not emptyp(_v) and is(first(_v) = false)
               then (extra_integration_methods:[],
                     extra_definite_integration_methods:[],_useabsint:false)
               elseif listp(_v) and not emptyp(_v) and is(first(_v) = true)
               then (extra_integration_methods:copy(_eim),
                     extra_definite_integration_methods:copy(_edim),
                     _useabsint:true),
           if _useabsint
               then "additional integration methods from abs_integrate.mac will be used"
               else "additional integration methods from abs_integrate.mac will not be used") */ 
/* Expected result: */
gradef(pwdelta(__x),diff_pwdelta(1,__x));

/* Problem 12 (line 121) */
gradef(diff_pwdelta(__nn,__x),und,diff_pwdelta(__nn+1,__x));
/* Erroneous Result?:
diff_pwdelta(__nn,__x) */ 
/* Expected result: */
inpargs(__e):=block([inflag:true],
        if mapatom(__e) then [__e] else substinpart("[",__e,0));

/* Problem 13 (line 124) */
freeofall(__vlist,__e):=block([_ans],_ans:true,
          for _v in __vlist while _ans do
              if not freeof(_v,__e) then _ans:false,_ans);
/* Erroneous Result?:
freeofall(__vlist,__e):=block([_ans],_ans:true,
          for _v in __vlist while _ans do
              if not freeof(_v,__e) then _ans:false,_ans) */ 
/* Expected result: */
not_op(__e):=psubst(
       ['notequal = 'equal,'equal = 'notequal,">" = "<=",">=" = "<",
        "<" = ">=","<=" = ">"],__e);

/* Problem 14 (line 137) */
simp_iif(__e):=block([_done:false,inflag:true],
         while not _done do
               if is(equal(isimp(__e),__e)) # true then __e:isimp(__e)
                   else _done:true,__e);
/* Erroneous Result?:
simp_iif(__e):=block([_done:false,inflag:true],
         while not _done do
               if is(equal(isimp(__e),__e)) # true then __e:isimp(__e)
                   else _done:true,__e) */ 
/* Expected result: */
isimp(__e):=block([opsubst:true,inflag:true],
      simp_given(subst(iif = lambda([__cnd,__a,__b],
                                    if is(equal(__a,__b)) = true then __a
                                        elseif safe_op(__cnd) = 'equal
                                        then iif(__cnd,
                                                 ratsubst(inpart(__cnd,2),
                                                          inpart(__cnd,1),
                                                          __a),__b)
                                        elseif safe_op(__cnd) = 'notequal
                                        then iif(__cnd,__a,
                                                 ratsubst(inpart(__cnd,2),
                                                          inpart(__cnd,1),
                                                          __b))
                                        else iif(__cnd,__a,__b)),__e)));

/* Problem 15 (line 170) */
simpiif(__cnd,__a,__b):=block([prederror:false],
        if not member(safe_op(__cnd),[">","<",">=","<=",'equal,'notequal])
            then error("The only operators allowed are >, <, >=, <=, equal() and notequal().")
            elseif is(__cnd) = true then __a elseif is(__cnd) = false then __b
            else simpfuncall('iif,__cnd,simp_given(__a,__cnd),
                             simp_given(__b,not_op(__cnd))));
/* Erroneous Result?:
simpiif(__cnd,__a,__b):=block([prederror:false],
        if not member(safe_op(__cnd),[">","<",">=","<=",'equal,'notequal])
            then error("The only operators allowed are >, <, >=, <=, equal() and notequal().")
            elseif is(__cnd) = true then __a elseif is(__cnd) = false then __b
            else simpfuncall('iif,__cnd,simp_given(__a,__cnd),
                             simp_given(__b,not_op(__cnd)))) */ 
/* Expected result: */
simpunitspike(__x):=block([prederror:false],
              if is(equal(__x,0)) = true then 1
                  elseif is(notequal(__x,0)) = true then 0
                  else simpfuncall('unit_spike,__x));

/* Problem 16 (line 197) */
simpunitpulse(__x):=block([prederror:false],
              if is(__x > 0 and __x < 1) = true then 1
                  elseif is(equal(__x,0)) = true then 1/2
                  elseif is(equal(__x,1)) = true then 1/2
                  elseif is(__x < 0 or __x > 1) = true then 0
                  else simpfuncall('unit_pulse,__x));
/* Erroneous Result?:
simpunitpulse(__x):=block([prederror:false],
              if is(__x > 0 and __x < 1) = true then 1
                  elseif is(equal(__x,0)) = true then 1/2
                  elseif is(equal(__x,1)) = true then 1/2
                  elseif is(__x < 0 or __x > 1) = true then 0
                  else simpfuncall('unit_pulse,__x)) */ 
/* Expected result: */
simppwdelta([__e]):=block([prederror:false],
            if length(__e) # 1
                then error("Error : pwdelta takes one argument.")
                elseif numberp(first(__e))
                 and is(notequal(first(__e),0)) = true then 0
                elseif numberp(first(__e)) and is(equal(first(__e),0)) = true
                then 'inf else simpfuncall('pwdelta,first(__e)));

/* Problem 17 (line 223) */
simpdiffpwdelta([__e]):=block([prederror:false],
                if length(__e) # 2
                    then error("Error : diff_pwdelta takes two arguments.")
                    elseif numberp(second(__e))
                     and is(notequal(second(__e),0)) = true then 0
                    elseif numberp(second(__e))
                     and is(equal(second(__e),0)) = true then 'und
                    else simpfuncall('diff_pwdelta,first(__e),second(__e)));
/* Erroneous Result?:
simpdiffpwdelta([__e]):=block([prederror:false],
                if length(__e) # 2
                    then error("Error : diff_pwdelta takes two arguments.")
                    elseif numberp(second(__e))
                     and is(notequal(second(__e),0)) = true then 0
                    elseif numberp(second(__e))
                     and is(equal(second(__e),0)) = true then 'und
                    else simpfuncall('diff_pwdelta,first(__e),second(__e))) */ 
/* Expected result: */
simpbetween(__x,__a,__b,[__option]):=block(
            [prederror:false,compxa:false,compxb:false],__x:rationalize(__x),
            __a:rationalize(__a),__b:rationalize(__b),
            if length(__option) > 1
                then error(concat("No version of between() takes ",
                                  length(__option)+3," arguments"))
                elseif is(__a >= __b) = true then 0
                elseif emptyp(__option) or first(__option) = 'halfopen
                then (if (compxa:sign(__x-__a)) = 'pos
                           and (compxb:sign(__x-__b)) = 'neg then 1
                          elseif compxa = 'neg or compxb = 'pos then 0
                          elseif compxa = 'zero or compxb = 'zero then 1/2
                          elseif __b = 'inf then (1+signum(__x-__a))/2
                          elseif __a = 'minf then (1-signum(__x-__b))/2
                          else simpfuncall('between,__x,__a,__b,'halfopen))
                elseif first(__option) = 'closed
                then (if member(compxa:sign(__x-__a),'([pos,pz,zero]))
                           and member(compxb:sign(__x-__b),'([neg,nz,zero]))
                          then 1 elseif compxa = 'neg or compxb = 'pos then 0
                          elseif __b = 'inf
                          then (1+signum(__x-__a)+unit_spike(__x-__a))/2
                          elseif __a = 'minf
                          then (1-signum(__x-__b)+unit_spike(__x-__b))/2
                          else simpfuncall('between,__x,__a,__b,
                                           first(__option)))
                elseif first(__option) = 'open
                then (if (compxa:sign(__x-__a)) = 'pos
                           and (compxb:sign(__x-__b)) = 'neg then 1
                          elseif member(compxa,'([neg,nz,zero]))
                           or member(compxb,'([pos,pz,zero])) then 0
                          elseif __b = 'inf
                          then (1+signum(__x-__a)-unit_spike(__x-__a))/2
                          elseif __a = 'minf
                          then (1-signum(__x-__b)-unit_spike(__x-__b))/2
                          else simpfuncall('between,__x,__a,__b,
                                           first(__option)))
                elseif first(__option) = 'rclosed
                then (if (compxa:sign(__x-__a)) = 'pos
                           and member(compxb:sign(__x-__b),'([neg,nz,zero]))
                          then 1
                          elseif member(compxa,'([neg,nz,zero]))
                           or compxb = 'pos then 0 elseif __b = 'inf
                          then (1+signum(__x-__a)-unit_spike(__x-__a))/2
                          elseif __a = 'minf
                          then (1-signum(__x-__b)+unit_spike(__x-__b))/2
                          else simpfuncall('between,__x,__a,__b,
                                           first(__option)))
                elseif first(__option) = 'lclosed
                then (if member(compxa:sign(__x-__a),'([pos,pz,zero]))
                           and (compxb:sign(__x-__b)) = 'neg then 1
                          elseif compxa = 'neg
                           or member(compxb,'([pos,pz,zero])) then 0
                          elseif __b = 'inf
                          then (1+signum(__x-__a)+unit_spike(__x-__a))/2
                          elseif __a = 'minf
                          then (1-signum(__x-__b)-unit_spike(__x-__b))/2
                          else simpfuncall('between,__x,__a,__b,
                                           first(__option)))
                else simpfuncall('between,__x,__a,__b,first(__option)));

/* Problem 18 (line 316) */
simplifying(iif,simpiif);
/* Erroneous Result?:
iif */ 
/* Expected result: */
simplifying(unit_spike,simpunitspike);

/* Problem 19 (line 318) */
simplifying(unit_pulse,simpunitpulse);
/* Erroneous Result?:
unit_pulse */ 
/* Expected result: */
simplifying(between,simpbetween);

/* Problem 20 (line 320) */
simplifying(pwdelta,simppwdelta);
/* Erroneous Result?:
pwdelta */ 
/* Expected result: */
simplifying(diff_pwdelta,simpdiffpwdelta);

/* Problem 21 (line 340) */
linearfunc(__e,__x):=block([inflag:true,ratprint:false,_a,_b,_retval],
           errcatch(_b:subst(0,__x,__e),_a:subst(1,__x,__e)-_b,
                    if is(equal(radcan(_a*__x+_b-__e),0)) = true
                        then _retval:[_a,_b] else _retval:false),
           if %% = false or emptyp(%%) then false else _retval);
/* Erroneous Result?:
linearfunc(__e,__x):=block([inflag:true,ratprint:false,_a,_b,_retval],
           errcatch(_b:subst(0,__x,__e),_a:subst(1,__x,__e)-_b,
                    if is(equal(radcan(_a*__x+_b-__e),0)) = true
                        then _retval:[_a,_b] else _retval:false),
           if %% = false or emptyp(%%) then false else _retval) */ 
/* Expected result: */
quadraticfunc(__e,__x):=block(
              [inflag:true,algebraic:true,ratprint:false,_p,_q,_r,_retval],
              errcatch(_p:subst(0,__x,__e),_q:subst(1,__x,__e),
                       _r:subst(2,__x,__e),
                       if is(equal(radcan(
                                    ((_r-2*_q+_p)/2)*__x^2
                                     +((4*_q-_r+(-3)*_p)/2)*__x+_p-__e),0))
                            = true
                           then _retval:radcan(
                                        [(_r-2*_q+_p)/2,(4*_q-_r+(-3)*_p)/2,
                                         _p]) else _retval:false),
              if %% = false or emptyp(%%) then false else _retval);

/* Problem 22 (line 393) */
list_remove(__l,__n,__m):=block([partswitch:true,_retval:"error occurred"],
            if listp(__l)
                then (errcatch(if __n > length(__l) then __retval:__l
                                   elseif length(__l) > __n+__m-2 and __m >= 0
                                   then (if __n > 0
                                             then _retval
                                             :append(
                                              rest(__l,__n-1-length(__l)),
                                              rest(__l,__n+__m-1)))
                                   elseif __m >= 0
                                   then (if __n > 0
                                             then _retval
                                             :rest(__l,__n-1-length(__l)))),
                      if %% = [] then _retval:["Something went wrong"])
                else _retval:["L is not a list"],_retval);
/* Erroneous Result?:
list_remove(__l,__n,__m):=block([partswitch:true,_retval:"error occurred"],
            if listp(__l)
                then (errcatch(if __n > length(__l) then __retval:__l
                                   elseif length(__l) > __n+__m-2 and __m >= 0
                                   then (if __n > 0
                                             then _retval
                                             :append(
                                              rest(__l,__n-1-length(__l)),
                                              rest(__l,__n+__m-1)))
                                   elseif __m >= 0
                                   then (if __n > 0
                                             then _retval
                                             :rest(__l,__n-1-length(__l)))),
                      if %% = [] then _retval:["Something went wrong"])
                else _retval:["L is not a list"],_retval) */ 
/* Expected result: */
factor_signum:true;

/* Problem 23 (line 464) */
pwint(__e,__x,[__v]):=block(
      [inflag:true,_f:__e,_retval,_funcs,_scnmp:false,_p,_args,_l,_funcs,
       _go:false],
      if mapatom(__x)
          then (if length(__v) = 2 then apply('pwdefint,flatten([_f,__x,__v]))
                    elseif length(__v) = 0
                    then (if not freeof('signum,
                                        gatherargs(unitstep2signum(_f),
                                                   'signum))
                              then (_f:pwsimp(_f,__x),_f:zerospikes(_f),
                                    if freeof('signum,
                                              gatherargs(unitstep2signum(_f),
                                                         'signum))
                                        then _go:true) else _go:true,
                          _args:gatherargs(_f,"^"),
                          for _p in _args do
                              if is(equal(second(_p),1/2)) = true
                                  then _scnmp:true,
                          if _scnmp = true then _f:scanmap('factor,_f),
                          _f:maxmin2iif(_f),_f:if2sum(_f),_f:iif2sum(_f),
                          _f:abs2signum(_f),_f:hstep2signum(_f),
                          _f:charfun2sum(_f),_f:simpunitstep(_f,__x),
                          _f:unitstep2signum(_f),
                          if member(factor_signum,['true,'all])
                              then _f:simpsignum(_f),
                          if factor_signum = 'all
                              then _f:simpsignumargs(_f,__x),
                          _f:zerospikes(_f),
                          _f:expandwrt(_f,'signum,'pwdelta,'diff_pwdelta,
                                       'between,'unit_pulse),
                          if _go
                              then (_retval:_pwint(_f,__x),
                                    if not freeof('integrate,_retval)
                                        then funmake(nounify('integrate),
                                                     [__e,__x])
                                        else _retval
                                        :zeroconstterms(_retval,__x))
                              else funmake(nounify('integrate),[__e,__x]))
                    else error("Wrong number of arguments to pwint."))
          else error("Variable of integration must be a symbol.")),factor_signum = true;
/* Erroneous Result?:
pwint(__e,__x,[__v]):=block(
      [inflag:true,_f:__e,_retval,_funcs,_scnmp:false,_p,_args,_l,_funcs,
       _go:false],
      if mapatom(__x)
          then (if length(__v) = 2 then apply('pwdefint,flatten([_f,__x,__v]))
                    elseif length(__v) = 0
                    then (if not freeof('signum,
                                        gatherargs(unitstep2signum(_f),
                                                   'signum))
                              then (_f:pwsimp(_f,__x),_f:zerospikes(_f),
                                    if freeof('signum,
                                              gatherargs(unitstep2signum(_f),
                                                         'signum))
                                        then _go:true) else _go:true,
                          _args:gatherargs(_f,"^"),
                          for _p in _args do
                              if is(equal(second(_p),1/2)) = true
                                  then _scnmp:true,
                          if _scnmp = true then _f:scanmap('factor,_f),
                          _f:maxmin2iif(_f),_f:if2sum(_f),_f:iif2sum(_f),
                          _f:abs2signum(_f),_f:hstep2signum(_f),
                          _f:charfun2sum(_f),_f:simpunitstep(_f,__x),
                          _f:unitstep2signum(_f),
                          if member(factor_signum,['true,'all])
                              then _f:simpsignum(_f),
                          if factor_signum = 'all
                              then _f:simpsignumargs(_f,__x),
                          _f:zerospikes(_f),
                          _f:expandwrt(_f,'signum,'pwdelta,'diff_pwdelta,
                                       'between,'unit_pulse),
                          if _go
                              then (_retval:_pwint(_f,__x),
                                    if not freeof('integrate,_retval)
                                        then funmake(nounify('integrate),
                                                     [__e,__x])
                                        else _retval
                                        :zeroconstterms(_retval,__x))
                              else funmake(nounify('integrate),[__e,__x]))
                    else error("Wrong number of arguments to pwint."))
          else error("Variable of integration must be a symbol.")) */ 
/* Expected result: */
_pwint(__e,__x):=block([inflag:true,_sum:0,_op,_q],
       _op:if not mapatom(__e) then op(__e),
       if _op = "+" then (for _q in __e do _sum:_sum+intterm(_q,__x),_sum)
           elseif _op = "*" then intterm(__e,__x) elseif _op = "^"
           then (if safe_op(expandwrt(__e,'signum,'pwdelta,'diff_pwdelta,
                                      'between,'unit_pulse))
                      # "^"
                     then pwint(expandwrt(__e,'signum,'pwdelta,'diff_pwdelta,
                                          'between,'unit_pulse),__x)
                     else intterm(__e,__x)) elseif _op = 'signum
           then intterm(__e,__x) elseif _op = 'unit_pulse
           then intterm(__e,__x) elseif _op = 'between
           then intbetween(__e,__x) elseif _op = 'pwdelta
           then intpwdelta(__e,__x) elseif _op = 'sum then intterm(__e,__x)
           elseif not freeof('sum,__e) and not emptyp(gatherargs(__e,'sum))
                                       and length(gatherargs(__e,'sum)) = 1
           then intterm(__e,__x) elseif _op = 'diff_pwdelta
           then intdiffpwdelta(__e,__x)
           elseif freeof('signum,'pwdelta,'diff_pwdelta,'between,'unit_pulse,
                         __e) then integrate(__e,__x)
           else funmake(nounify('integrate),[__e,__x]));

/* Problem 24 (line 534) */
__pwint(__e,__x):=block([inflag:true],__e:zerospikes(__e),
        __e:expandwrt(__e,'signum,'pwdelta,'diff_pwdelta,'between,
                      'unit_pulse),
        if freeof('signum,gatherargs(__e,'signum)) then _pwint(__e,__x)
            else funmake(nounify('integrate),[__e,__x]));
/* Erroneous Result?:
__pwint(__e,__x):=block([inflag:true],__e:zerospikes(__e),
        __e:expandwrt(__e,'signum,'pwdelta,'diff_pwdelta,'between,
                      'unit_pulse),
        if freeof('signum,gatherargs(__e,'signum)) then _pwint(__e,__x)
            else funmake(nounify('integrate),[__e,__x])) */ 
/* Expected result: */
___pwint(__e,__x):=block([inflag:true],__e:abs2signum(__e),
         __e:zerospikes(__e),
         __e:expandwrt(__e,'signum,'pwdelta,'diff_pwdelta,'between,
                       'unit_pulse),
         if freeof('signum,gatherargs(__e,'signum)) then _pwint(__e,__x)
             else funmake(nounify('integrate),[__e,__x]));

/* Problem 25 (line 675) */
intterm(__e,__x):=block(
        [inflag:true,_t,_sum:0,_tmpt,_tmp1,_tmp2,_t1,_t2,_errflag:false,_op],
        _op:if not mapatom(__e) then op(__e),
        if _op = "*"
            then (_t1:xreduce("*",
                              sublist(args(__e),lambda([_z],freeof(__x,_z)))),
                  _t2:xreduce("*",
                              sublist(args(__e),
                                      lambda([_z],not freeof(__x,_z)))))
            elseif _op = "^"
            then (_t1:_t2:1,if freeof(__x,__e) then _t1:__e else _t2:__e)
            elseif _op = "+" then print("Not a term")
            elseif not freeof('sum,__e)
            then (if safe_op(__e) = "*"
                      then (_t1:xreduce("*",
                                        sublist(args(__e),
                                                lambda([_z],freeof(__x,_z)))),
                            _t2:xreduce("*",
                                        sublist(args(__e),
                                                lambda([_z],
                                                       not freeof(__x,_z)))))
                      elseif not freeof('sum,__e)
                       and not emptyp(gatherargs(__e,'sum))
                       and length(gatherargs(__e,'sum)) = 1
                      then (_t1:1,_t2:__e) else print("Not a Term"))
            else (_t1:_t2:1,if freeof(__x,__e) then _t1:__e else _t2:__e),
        if not freeof('sum,_t2)
            then (_tmp1:gatherargs(_t2,'sum),
                  if length(_tmp1) = 1
                      then (_tmp1:first(_tmp1),
                            _tmp2:_t2/apply('sum,
                                            [first(_tmp1),second(_tmp1),
                                             third(_tmp1),fourth(_tmp1)]),
                            _tmpt:pwint(first(_tmp1)*_tmp2,__x),
                            _t1*apply('sum,
                                      [_tmpt,second(_tmp1),third(_tmp1),
                                       fourth(_tmp1)]))
                      else funmake(nounify('integrate),[__e,__x]))
            elseif not freeof('pwdelta,_t2) then _t1*intpwdelta(_t2,__x)
            elseif not freeof('diff_pwdelta,_t2)
            then _t1*intdiffpwdelta(_t2,__x) elseif not freeof('between,_t2)
            then (_t:betweencheck(_t2),
                  if _t = false then funmake(nounify('integrate),[__e,__x])
                      else _t1*intbetween(_t,__x))
            elseif not freeof('unit_pulse,_t2)
            then (_t:pulsecheck(_t2),
                  if _t = false then funmake(nounify('integrate),[__e,__x])
                      else _t1*intpulse(_t,__x))
            elseif not freeof('signum,_t2)
            then (_t:signumcheck(_t2),
                  if _t = false
                      then (_tmpt:pwsimp(_t2,__x,'signum),
                            _t:signumcheck(_tmpt),
                            if _t = 'false then integrate(_t1*_tmpt,__x)
                                else (if freeof('signum,_t)
                                          then _t1*integrate(_t,__x)
                                          else (if 
                                          safe_op(_t) = 'signum
                                            or safe_op(_t) = "*"
                                            or safe_op(_t) = "^"
                                           then _t1*intsignum(_t,__x)
                                           else _t1*pwint(_t,__x))))
                      else (if freeof('signum,_t) then _t1*integrate(_t,__x)
                                else (if 
                                safe_op(_t) = 'signum or safe_op(_t) = "*"
                                                      or safe_op(_t) = "^"
                                 then _t1*intsignum(_t,__x)
                                 else _t1*pwint(_t,__x))))
            elseif freeof('signum,'pwdelta,'diff_pwdelta,'between,'unit_pulse,
                          __e) then integrate(__e,__x)
            else funmake(nounify('integrate),[__e,__x]));
/* Erroneous Result?:
intterm(__e,__x):=block(
        [inflag:true,_t,_sum:0,_tmpt,_tmp1,_tmp2,_t1,_t2,_errflag:false,_op],
        _op:if not mapatom(__e) then op(__e),
        if _op = "*"
            then (_t1:xreduce("*",
                              sublist(args(__e),lambda([_z],freeof(__x,_z)))),
                  _t2:xreduce("*",
                              sublist(args(__e),
                                      lambda([_z],not freeof(__x,_z)))))
            elseif _op = "^"
            then (_t1:_t2:1,if freeof(__x,__e) then _t1:__e else _t2:__e)
            elseif _op = "+" then print("Not a term")
            elseif not freeof('sum,__e)
            then (if safe_op(__e) = "*"
                      then (_t1:xreduce("*",
                                        sublist(args(__e),
                                                lambda([_z],freeof(__x,_z)))),
                            _t2:xreduce("*",
                                        sublist(args(__e),
                                                lambda([_z],
                                                       not freeof(__x,_z)))))
                      elseif not freeof('sum,__e)
                       and not emptyp(gatherargs(__e,'sum))
                       and length(gatherargs(__e,'sum)) = 1
                      then (_t1:1,_t2:__e) else print("Not a Term"))
            else (_t1:_t2:1,if freeof(__x,__e) then _t1:__e else _t2:__e),
        if not freeof('sum,_t2)
            then (_tmp1:gatherargs(_t2,'sum),
                  if length(_tmp1) = 1
                      then (_tmp1:first(_tmp1),
                            _tmp2:_t2/apply('sum,
                                            [first(_tmp1),second(_tmp1),
                                             third(_tmp1),fourth(_tmp1)]),
                            _tmpt:pwint(first(_tmp1)*_tmp2,__x),
                            _t1*apply('sum,
                                      [_tmpt,second(_tmp1),third(_tmp1),
                                       fourth(_tmp1)]))
                      else funmake(nounify('integrate),[__e,__x]))
            elseif not freeof('pwdelta,_t2) then _t1*intpwdelta(_t2,__x)
            elseif not freeof('diff_pwdelta,_t2)
            then _t1*intdiffpwdelta(_t2,__x) elseif not freeof('between,_t2)
            then (_t:betweencheck(_t2),
                  if _t = false then funmake(nounify('integrate),[__e,__x])
                      else _t1*intbetween(_t,__x))
            elseif not freeof('unit_pulse,_t2)
            then (_t:pulsecheck(_t2),
                  if _t = false then funmake(nounify('integrate),[__e,__x])
                      else _t1*intpulse(_t,__x))
            elseif not freeof('signum,_t2)
            then (_t:signumcheck(_t2),
                  if _t = false
                      then (_tmpt:pwsimp(_t2,__x,'signum),
                            _t:signumcheck(_tmpt),
                            if _t = 'false then integrate(_t1*_tmpt,__x)
                                else (if freeof('signum,_t)
                                          then _t1*integrate(_t,__x)
                                          else (if 
                                          safe_op(_t) = 'signum
                                            or safe_op(_t) = "*"
                                            or safe_op(_t) = "^"
                                           then _t1*intsignum(_t,__x)
                                           else _t1*pwint(_t,__x))))
                      else (if freeof('signum,_t) then _t1*integrate(_t,__x)
                                else (if 
                                safe_op(_t) = 'signum or safe_op(_t) = "*"
                                                      or safe_op(_t) = "^"
                                 then _t1*intsignum(_t,__x)
                                 else _t1*pwint(_t,__x))))
            elseif freeof('signum,'pwdelta,'diff_pwdelta,'between,'unit_pulse,
                          __e) then integrate(__e,__x)
            else funmake(nounify('integrate),[__e,__x])) */ 
/* Expected result: */
intpwdelta(__term,__x):=block([inflag:true,_a,_s,_ans,_lans,_z],
           _a:block([_s],_s:gatherargs(__term,'pwdelta),_s),_a:flatten(_a),
           _s:pwdelta(first(_a)),
           if listp(_lans:linearfunc(first(_a),__x))
                and listp(linearfunc(__term,_s))
               then (_ans:(-second(_lans))/first(_lans),
                     _z:(at(((1/first(_lans))*__term)/_s,[__x = _ans])
                        *(signum(first(_a))+1))
                        /2) else funmake(nounify('integrate),[__term,__x]));

/* Problem 26 (line 709) */
intdiffpwdelta(__term,__x):=block([inflag:true,_a,_s,_ans,_lans,_z],
               _a:block([_s],_s:gatherargs(__term,'diff_pwdelta),_s),
               _s:diff_pwdelta(first(first(_a)),second(first(_a))),
               if listp(_lans:linearfunc(second(first(_a)),__x))
                    and nonnegintegerp(first(first(_a)))
                    and listp(linearfunc(__term,_s))
                   then (_ans:(-second(_lans))/first(_lans),
                         _z:((at(diff(((-1)^first(first(_a))*__term)/_s,__x,
                                      first(first(_a))),[__x = _ans])
                            *(signum(second(first(_a)))+1))
                            /first(_lans)^(first(first(_a))+1))
                            /2)
                   else funmake(nounify('integrate),[__term,__x]));
/* Erroneous Result?:
intdiffpwdelta(__term,__x):=block([inflag:true,_a,_s,_ans,_lans,_z],
               _a:block([_s],_s:gatherargs(__term,'diff_pwdelta),_s),
               _s:diff_pwdelta(first(first(_a)),second(first(_a))),
               if listp(_lans:linearfunc(second(first(_a)),__x))
                    and nonnegintegerp(first(first(_a)))
                    and listp(linearfunc(__term,_s))
                   then (_ans:(-second(_lans))/first(_lans),
                         _z:((at(diff(((-1)^first(first(_a))*__term)/_s,__x,
                                      first(first(_a))),[__x = _ans])
                            *(signum(second(first(_a)))+1))
                            /first(_lans)^(first(first(_a))+1))
                            /2)
                   else funmake(nounify('integrate),[__term,__x])) */ 
/* Expected result: */
intsignum(__term,__x):=block([inflag:true,_a,_z,__retval:0,_s,_t,_ans,_tmp],
          _a:flatten(listify(setify(gatherargs(__term,'signum)))),
          _s:signum(first(_a)),
          if listp(_ans:linearfunc(first(_a),__x))
              then (_ans:(-second(_ans))/first(_ans),
                    if not mapatom(__term) and op(__term) = 'signum
                        then (_z:subst(1,_s,__term),_z:integrate(_z,__x),
                              _t:errcatch(_z:(_z-at(_z,[__x = _ans]))*_s),
                              if _t = [] then _z:_z*_s)
                        else (_z:subst(1,_s,__term),
                              if freeof('abs,'signum,'between,_z)
                                  then _z:integrate(_z,__x)
                                  else _z:pwint(_z,__x),
                              _t:errcatch(_z:(_z-at(_z,[__x = _ans]))*_s),
                              if _t = [] then _z:_z*_s),_z)
              elseif freeof('abs,'signum,'pwdelta,'diff_pwdelta,'between,
                            __term) then integrate(__term,__x)
              else funmake(nounify('integrate),[__term,__x]));

/* Problem 27 (line 756) */
intpulse(__term,__x):=block(
         [inflag:true,_x,_a,_b,_o,_z,_t,_ans_a,_ans_b,_op,_l],
         between2unitpulse(intbetween(zerospikes(unitpulse2between(__term)),
                                      __x)));
/* Erroneous Result?:
intpulse(__term,__x):=block(
         [inflag:true,_x,_a,_b,_o,_z,_t,_ans_a,_ans_b,_op,_l],
         between2unitpulse(intbetween(zerospikes(unitpulse2between(__term)),
                                      __x))) */ 
/* Expected result: */
intbetween(__term,__x):=block(
           [inflag:true,_x,_a,_b,_o,_z,_t,_ans_a,_ans_b,_op,_l],
           _op:if not mapatom(__term) then op(__term),
           _l:listify(setify(gatherargs(__term,'between))),_l:first(_l),
           _x:first(_l),_a:second(_l),_b:third(_l),
           _t:between(_x,_a,_b,fourth(_l)),
           if length(_l) > 0 and listp(_ans_a:linearfunc(_x-_a,__x))
                             and listp(_ans_b:linearfunc(_x-_b,__x))
               then (_ans_a:(-second(_ans_a))/first(_ans_a),
                     _ans_b:(-second(_ans_b))/first(_ans_b),
                     if _op = 'between
                         then (_z:__term/_t,_z:integrate(_z,__x),
                               _z:_z*between(_x,_a,_b)
                                  +((signum(_b-_a)+1)/2)
                                   *((at(_z,[__x = _ans_b])*(1+signum(_x-_b)))
                                    /2
                                    +(at(_z,[__x = _ans_a])*(1-signum(_x-_a)))
                                     /2)) elseif member(_t,args(__term))
                         then (_z:__term/_t,
                               if freeof('abs,'signum,'between,_z)
                                   then _z:integrate(_z,__x)
                                   else _z:pwint(_z,__x),
                               _z:_z*between(_x,_a,_b)
                                  +((signum(_b-_a)+1)/2)
                                   *((at(_z,[__x = _ans_b])*(1+signum(_x-_b)))
                                    /2
                                    +(at(_z,[__x = _ans_a])*(1-signum(_x-_a)))
                                     /2))
                         else _z:funmake(nounify('integrate),[__term,__x]),_z)
               elseif freeof('abs,'signum,'pwdelta,'diff_pwdelta,'between,
                             __term) then integrate(__term,__x)
               else funmake(nounify('integrate),[__term,__x]));

/* Problem 28 (line 817) */
linearize(__e):=block([inflag:true,_f:__e],
          if not mapatom(__e) and op(__e) = "+"
              then xreduce("+",map(lambda([_z],linearize(_z)),inpargs(__e)))
              elseif not mapatom(__e) and op(__e) = "*"
              then betweencheck(signumcheck(__e))
              elseif not mapatom(__e) and op(__e) = "^"
              then betweencheck(signumcheck(__e)) else _f,
          if not freeof('false,%%) then _f else %%);
/* Erroneous Result?:
linearize(__e):=block([inflag:true,_f:__e],
          if not mapatom(__e) and op(__e) = "+"
              then xreduce("+",map(lambda([_z],linearize(_z)),inpargs(__e)))
              elseif not mapatom(__e) and op(__e) = "*"
              then betweencheck(signumcheck(__e))
              elseif not mapatom(__e) and op(__e) = "^"
              then betweencheck(signumcheck(__e)) else _f,
          if not freeof('false,%%) then _f else %%) */ 
/* Expected result: */
linearizesignum(__e):=block([inflag:true,__retval,_lk,_sum:0,_a,_p],
                __e:expandwrt(__e,'signum),
                if not mapatom(__e) and op(__e) = "+"
                    then (for _p in __e do _sum:_sum+linearizesignum(_p),_sum)
                    else (__retval:__e,_a:gatherargs(__e,"^"),
                          map(lambda([_lk],
                                     if 
                                      not mapatom(first(_lk))
                                        and op(first(_lk)) = 'signum
                                        and oddp(second(_lk))
                                       then __retval
                                       :subst(first(_lk),
                                              first(_lk)^second(_lk),__retval)
                                       elseif not mapatom(first(_lk))
                                        and op(first(_lk)) = 'signum
                                        and evenp(second(_lk))
                                       then __retval
                                       :subst(
                                        1-unit_spike(first(args(first(_lk)))),
                                        first(_lk)^second(_lk),__retval)),_a),
                          __retval));

/* Problem 29 (line 893) */
signumcheck(__e):=block(
            [inflag:true,__retval,_lk,_e,_q,_args,_dv,_go:true,_sum:0,_a],
            if not mapatom(__e) and op(__e) = "+"
                then (for _p in __e do _sum:_sum+signumcheck(_p),
                      if freeof('false,_sum) then _sum else 'false)
                else (__retval:__e,_a:gatherargs(__e,"^"),
                      map(lambda([_lk],
                                 if not mapatom(first(_lk))
                                      and op(first(_lk)) = 'signum
                                      and oddp(second(_lk))
                                     then __retval
                                     :subst(first(_lk),first(_lk)^second(_lk),
                                            __retval)
                                     elseif not mapatom(first(_lk))
                                      and op(first(_lk)) = 'signum
                                      and evenp(second(_lk))
                                     then __retval
                                     :subst(1-unit_spike(_lk),
                                            first(_lk)^second(_lk),__retval)),
                          _a),
                      _args:block([_s],_s:gatherargs(__retval,'signum),
                                  flatten(listify(setify(_s)))),
                      if not freeofall(['signum,'unit_spike],_args)
                          then (__retval:false,_args:[]),
                      while length(_args) > 0 do
                            (_q:first(_args),_args:rest(_args),_dv:signum(_q),
                             if not listp(linearfunc(__retval,_dv))
                                 then (__retval:false,_args:[])),__retval));
/* Erroneous Result?:
signumcheck(__e):=block(
            [inflag:true,__retval,_lk,_e,_q,_args,_dv,_go:true,_sum:0,_a],
            if not mapatom(__e) and op(__e) = "+"
                then (for _p in __e do _sum:_sum+signumcheck(_p),
                      if freeof('false,_sum) then _sum else 'false)
                else (__retval:__e,_a:gatherargs(__e,"^"),
                      map(lambda([_lk],
                                 if not mapatom(first(_lk))
                                      and op(first(_lk)) = 'signum
                                      and oddp(second(_lk))
                                     then __retval
                                     :subst(first(_lk),first(_lk)^second(_lk),
                                            __retval)
                                     elseif not mapatom(first(_lk))
                                      and op(first(_lk)) = 'signum
                                      and evenp(second(_lk))
                                     then __retval
                                     :subst(1-unit_spike(_lk),
                                            first(_lk)^second(_lk),__retval)),
                          _a),
                      _args:block([_s],_s:gatherargs(__retval,'signum),
                                  flatten(listify(setify(_s)))),
                      if not freeofall(['signum,'unit_spike],_args)
                          then (__retval:false,_args:[]),
                      while length(_args) > 0 do
                            (_q:first(_args),_args:rest(_args),_dv:signum(_q),
                             if not listp(linearfunc(__retval,_dv))
                                 then (__retval:false,_args:[])),__retval)) */ 
/* Expected result: */
betweencheck(__e):=block(
             [inflag:true,__retval,_lk,_e,_q,_args,_dv,_go:true,_sum:0,_a],
             if not mapatom(__e) and op(__e) = "+"
                 then (for _p in __e do _sum:_sum+betweencheck(_p),
                       if freeof('false,_sum) then _sum else 'false)
                 else (__retval:__e,_a:gatherargs(__e,"^"),
                       map(lambda([_lk],
                                  if not mapatom(first(_lk))
                                       and op(first(_lk)) = 'between
                                       and second(_lk) > 0
                                      then __retval
                                      :subst(first(_lk),
                                             first(_lk)^second(_lk),
                                             __retval)),_a),
                       _args:block([_s],_s:gatherargs(__retval,'between),
                                   listify(setify(_s))),
                       while length(_args) > 0 do
                             (_q:first(_args),_args:rest(_args),
                              _dv:apply('between,_q),
                              if not listp(linearfunc(__retval,_dv))
                                  then (__retval:false,_args:[])),__retval));

/* Problem 30 (line 978) */
pulsecheck(__e):=block(
           [inflag:true,__retval,_lk,_e,_q,_args,_dv,_go:true,_sum:0,_a],
           if not mapatom(__e) and op(__e) = "+"
               then (for _p in __e do _sum:_sum+pulsecheck(_p),
                     if freeof('false,_sum) then _sum else 'false)
               else (__retval:__e,_a:gatherargs(__e,"^"),
                     map(lambda([_lk],
                                if not mapatom(first(_lk))
                                     and op(first(_lk)) = 'unit_pulse
                                     and second(_lk) > 0
                                    then __retval
                                    :subst(first(_lk),first(_lk)^second(_lk),
                                           __retval)),_a),
                     _args:block([_s],_s:gatherargs(__retval,'unit_pulse),
                                 flatten(listify(setify(_s)))),
                     if not freeof('signum,'unit_spike,_args)
                         then (__retval:false,_args:[]),
                     while length(_args) > 0 do
                           (_q:first(_args),_args:rest(_args),
                            _dv:unit_pulse(_q),
                            if not listp(linearfunc(__retval,_dv))
                                then (__retval:false,_args:[])),__retval));
/* Erroneous Result?:
pulsecheck(__e):=block(
           [inflag:true,__retval,_lk,_e,_q,_args,_dv,_go:true,_sum:0,_a],
           if not mapatom(__e) and op(__e) = "+"
               then (for _p in __e do _sum:_sum+pulsecheck(_p),
                     if freeof('false,_sum) then _sum else 'false)
               else (__retval:__e,_a:gatherargs(__e,"^"),
                     map(lambda([_lk],
                                if not mapatom(first(_lk))
                                     and op(first(_lk)) = 'unit_pulse
                                     and second(_lk) > 0
                                    then __retval
                                    :subst(first(_lk),first(_lk)^second(_lk),
                                           __retval)),_a),
                     _args:block([_s],_s:gatherargs(__retval,'unit_pulse),
                                 flatten(listify(setify(_s)))),
                     if not freeof('signum,'unit_spike,_args)
                         then (__retval:false,_args:[]),
                     while length(_args) > 0 do
                           (_q:first(_args),_args:rest(_args),
                            _dv:unit_pulse(_q),
                            if not listp(linearfunc(__retval,_dv))
                                then (__retval:false,_args:[])),__retval)) */ 
/* Expected result: */
pwsimp(__e,__x,[__options]):=block(
       [partswitch:true,use_between:false,inflag:true,opsubst:true,__retval:0,
        _q,_t1,_t2,_sort_failed:false],_f:between2iif(__e),_f:maxmin2iif(_f),
       errcatch(_f:ifthen2if(_f)),_f:if2sum(_f),_f:iif2sum(_f),
       _f:charfun2sum(_f),__options:flatten(__options),_f:simppwdeltas(_f),
       if not freeof('unit_step,_f)
           then _f:scanmap(lambda([_z],simpunitstep(_z,__x)),_f),
       _f:convertall2signum(_f),_f:unitspike2signum(_f),
       if global = false then _f:expandwrt(_f,'signum,'unit_spike),
       if global = true then __retval:_nsignumsimp(_f,__x,__options)
           else (if not mapatom(_f) and op(_f) = "+"
                     then (for _q in args(_f) do
                               __retval:__retval
                                        +_nsignumsimp(_q,__x,__options))
                     elseif not mapatom(_f) and op(_f) = "*"
                     then (_t1:xreduce("*",
                                       sublist(args(_f),
                                               lambda([z],freeof(__x,z)))),
                           _t2:xreduce("*",
                                       sublist(args(_f),
                                               lambda([z],
                                                      not freeof(__x,z)))),
                           __retval:_t1*_nsignumsimp(_t2,__x,__options))
                     else __retval:_nsignumsimp(_f,__x,__options)),
       if _sort_failed = true then __e else __retval);

/* Problem 31 (line 1132) */
_nsignumsimp(__e,__x,__options):=block(
             [inflag:true,use_between:false,_q,_ans:[],_args,_args2:[],_yesno,
              _lkq,_p1,_p2,_t,_tmp,_tmplist,_nothing,_done,_l,_anst,_f:__e],
             __options:flatten(__options),
             _args:block([_s],_s:gatherargs(_f,'signum),
                         _s:listify(setify(_s)),_s),
             if not emptyp(_args)
                 then (_t:[['minf,__x-'minf]],
                       while not emptyp(_args) do
                             (_q:first(_args),_args:rest(_args),
                              _lkq:quadraticfunc(first(_q),__x),
                              if listp(_lkq)
                                  then (if 
                                  is(equal(first(_lkq),0)) = true
                                    and is(equal(second(_lkq),0)) = true
                                   then 6+9
                                   elseif is(equal(first(_lkq),0)) = true
                                   then (
                                   _temp:cons((-third(_lkq))/second(_lkq),_q),
                                   _t:cons(_temp,_t))
                                   elseif is(
                                   equal(
                                    second(_lkq)^2-4*first(_lkq)*third(_lkq),
                                    0))
                                    = true
                                   then (
                                   _temp
                                    :cons((-second(_lkq))/(2*first(_lkq)),_q),
                                   _t:cons(_temp,_t))
                                   elseif is(
                                   second(_lkq)^2-4*first(_lkq)*third(_lkq)
                                     > 0)
                                    = true
                                   then (
                                   _temp
                                    :cons(
                                     ((-second(_lkq))
                                      +sqrt(
                                       second(_lkq)^2
                                        -4*first(_lkq)*third(_lkq)))
                                      /(2*first(_lkq)),_q),_t:cons(_temp,_t),
                                   _temp
                                    :cons(
                                     ((-second(_lkq))
                                      -sqrt(
                                       second(_lkq)^2
                                        -4*first(_lkq)*third(_lkq)))
                                      /(2*first(_lkq)),_q),_t:cons(_temp,_t))
                                   elseif is(
                                   second(_lkq)^2-4*first(_lkq)*third(_lkq)
                                     < 0)
                                    = true then 6+9 else 6+9) else 6+9),
                       _t:cons(['inf,__x-'inf],_t),
                       if not emptyp(_t) and length(_t) > 1
                           then (_t:sort(_t,
                                         lambda([c1,c2],
                                                block([t],
                                                      t
                                                       :errcatch(
                                                        is(
                                                         is(
                                                          first(c1)
                                                            < first(c2))
                                                           = 'true)),
                                                      if emptyp(t) then 'false
                                                          else first(%%)))),
                                 _tmp:false,
                                 for i thru length(_t)-1 do
                                     if 
                                     is(first(_t[i]) <= first(_t[i+1]))
                                       = 'unknown
                                      then (_tmp:true,_sort_failed:true),
                                 if equal(_tmp,true) then _ans:__e
                                     else (_tmplist:[],
                                           while
                                             not emptyp(_t) and length(_t) > 1
                                             do
                                             (_tmp:_f,_p1:first(_t),
                                              _p2:second(_t),_t:rest(_t),
                                              _tmp
                                               :simp_given(_tmp,
                                                           first(_p1) < __x,
                                                           __x < first(_p2)),
                                              errcatch(
                                               _anst
                                                :if 
                                                 not member(first(_p1),
                                                            ['minf,'inf])
                                                  then sublis(
                                                  [__x = first(_p1)],
                                                  ratsimp(_f))),
                                              if %% = [] then _anst:'und,
                                              _tmplist
                                               :flatten(
                                                cons(
                                                 [_tmp,first(_p1),_anst,
                                                  first(_p1)],_tmplist))),
                                           _tmplist
                                            :flatten(
                                             cons(
                                              [first(_p2),
                                               if 
                                                not member(first(_p2),
                                                           ['minf,'inf])
                                                 then sublis(
                                                 [__x = first(_p2)],
                                                 ratsimp(_f)) else 'ind,
                                               first(_p2)],_tmplist)),
                                           if 
                                            first(_tmplist) = 'inf
                                              and third(_tmplist) = 'inf
                                             then _tmplist:rest(_tmplist,2),
                                           _tmplist:reverse(_tmplist),
                                           if 
                                            first(_tmplist) = 'minf
                                              and third(_tmplist) = 'minf
                                             then _tmplist:rest(_tmplist,2),
                                           for i thru length(__options) do
                                               if 
                                               member(__options[i],['connect])
                                                 = true
                                                then (
                                                __options
                                                 :list_remove(__options,i,1),
                                                i:length(__options)+100^100),
                                           for i thru length(__options) do
                                               if 
                                               member(__options[i],
                                                      ['closed,'open,'lclosed,
                                                       'rclosed,'halfopen])
                                                 = true
                                                then (
                                                __options
                                                 :list_remove(__options,i,1),
                                                i:i-1),
                                           if member('list,__options)
                                               then _ans:_tmplist
                                               elseif member('iif,__options)
                                               then _ans
                                               :simp_iif(
                                                pw(_tmplist,__x,
                                                   cons('open,__options)))
                                               else _ans
                                               :simpspikes(
                                                pw(_tmplist,__x,
                                                   cons('open,__options)))))
                           else _ans:__e) else _ans:__e,_ans),use_between = false;
/* Erroneous Result?:
_nsignumsimp(__e,__x,__options):=block(
             [inflag:true,use_between:false,_q,_ans:[],_args,_args2:[],_yesno,
              _lkq,_p1,_p2,_t,_tmp,_tmplist,_nothing,_done,_l,_anst,_f:__e],
             __options:flatten(__options),
             _args:block([_s],_s:gatherargs(_f,'signum),
                         _s:listify(setify(_s)),_s),
             if not emptyp(_args)
                 then (_t:[['minf,__x-'minf]],
                       while not emptyp(_args) do
                             (_q:first(_args),_args:rest(_args),
                              _lkq:quadraticfunc(first(_q),__x),
                              if listp(_lkq)
                                  then (if 
                                  is(equal(first(_lkq),0)) = true
                                    and is(equal(second(_lkq),0)) = true
                                   then 6+9
                                   elseif is(equal(first(_lkq),0)) = true
                                   then (
                                   _temp:cons((-third(_lkq))/second(_lkq),_q),
                                   _t:cons(_temp,_t))
                                   elseif is(
                                   equal(
                                    second(_lkq)^2-4*first(_lkq)*third(_lkq),
                                    0))
                                    = true
                                   then (
                                   _temp
                                    :cons((-second(_lkq))/(2*first(_lkq)),_q),
                                   _t:cons(_temp,_t))
                                   elseif is(
                                   second(_lkq)^2-4*first(_lkq)*third(_lkq)
                                     > 0)
                                    = true
                                   then (
                                   _temp
                                    :cons(
                                     ((-second(_lkq))
                                      +sqrt(
                                       second(_lkq)^2
                                        -4*first(_lkq)*third(_lkq)))
                                      /(2*first(_lkq)),_q),_t:cons(_temp,_t),
                                   _temp
                                    :cons(
                                     ((-second(_lkq))
                                      -sqrt(
                                       second(_lkq)^2
                                        -4*first(_lkq)*third(_lkq)))
                                      /(2*first(_lkq)),_q),_t:cons(_temp,_t))
                                   elseif is(
                                   second(_lkq)^2-4*first(_lkq)*third(_lkq)
                                     < 0)
                                    = true then 6+9 else 6+9) else 6+9),
                       _t:cons(['inf,__x-'inf],_t),
                       if not emptyp(_t) and length(_t) > 1
                           then (_t:sort(_t,
                                         lambda([c1,c2],
                                                block([t],
                                                      t
                                                       :errcatch(
                                                        is(
                                                         is(
                                                          first(c1)
                                                            < first(c2))
                                                           = 'true)),
                                                      if emptyp(t) then 'false
                                                          else first(%%)))),
                                 _tmp:false,
                                 for i thru length(_t)-1 do
                                     if 
                                     is(first(_t[i]) <= first(_t[i+1]))
                                       = 'unknown
                                      then (_tmp:true,_sort_failed:true),
                                 if equal(_tmp,true) then _ans:__e
                                     else (_tmplist:[],
                                           while
                                             not emptyp(_t) and length(_t) > 1
                                             do
                                             (_tmp:_f,_p1:first(_t),
                                              _p2:second(_t),_t:rest(_t),
                                              _tmp
                                               :simp_given(_tmp,
                                                           first(_p1) < __x,
                                                           __x < first(_p2)),
                                              errcatch(
                                               _anst
                                                :if 
                                                 not member(first(_p1),
                                                            ['minf,'inf])
                                                  then sublis(
                                                  [__x = first(_p1)],
                                                  ratsimp(_f))),
                                              if %% = [] then _anst:'und,
                                              _tmplist
                                               :flatten(
                                                cons(
                                                 [_tmp,first(_p1),_anst,
                                                  first(_p1)],_tmplist))),
                                           _tmplist
                                            :flatten(
                                             cons(
                                              [first(_p2),
                                               if 
                                                not member(first(_p2),
                                                           ['minf,'inf])
                                                 then sublis(
                                                 [__x = first(_p2)],
                                                 ratsimp(_f)) else 'ind,
                                               first(_p2)],_tmplist)),
                                           if 
                                            first(_tmplist) = 'inf
                                              and third(_tmplist) = 'inf
                                             then _tmplist:rest(_tmplist,2),
                                           _tmplist:reverse(_tmplist),
                                           if 
                                            first(_tmplist) = 'minf
                                              and third(_tmplist) = 'minf
                                             then _tmplist:rest(_tmplist,2),
                                           for i thru length(__options) do
                                               if 
                                               member(__options[i],['connect])
                                                 = true
                                                then (
                                                __options
                                                 :list_remove(__options,i,1),
                                                i:length(__options)+100^100),
                                           for i thru length(__options) do
                                               if 
                                               member(__options[i],
                                                      ['closed,'open,'lclosed,
                                                       'rclosed,'halfopen])
                                                 = true
                                                then (
                                                __options
                                                 :list_remove(__options,i,1),
                                                i:i-1),
                                           if member('list,__options)
                                               then _ans:_tmplist
                                               elseif member('iif,__options)
                                               then _ans
                                               :simp_iif(
                                                pw(_tmplist,__x,
                                                   cons('open,__options)))
                                               else _ans
                                               :simpspikes(
                                                pw(_tmplist,__x,
                                                   cons('open,__options)))))
                           else _ans:__e) else _ans:__e,_ans) */ 
/* Expected result: */
pw(__L,__x,[__options]):=block(
   [__M,__k,_options:[],__rslt,__ans:[],_ls,_rs,_c],
   __options:flatten(__options),_ls:"<",_rs:">",
   if member('array,__options) then _options:cons('array,_options)
       elseif member('between,__options) then _options:cons('between,_options)
       elseif member('signum,__options) then _options:cons('signum,_options),
   if member('lclosed,__options)
       then (_ls:"[",_rs:")",_options:cons('lclosed,_options))
       elseif member('rclosed,__options)
       then (_ls:"(",_rs:"]",_options:cons('rclosed,_options))
       elseif member('open,__options)
       then (_ls:"(",_rs:")",_options:cons('open,_options))
       elseif member('closed,__options)
       then (_ls:"[",_rs:"]",_options:cons('closed,_options))
       elseif member('halfopen,__options)
       then _options:cons('halfopen,_options),
   if listp(__L) and not emptyp(__L)
       then (if listp(__L[1]) and length(__L[1]) = 3
                 then (if member('connect,__options) and __L[1][1] # 'minf
                           then __L[1][3]
                           :__L[1][3]-limit(__L[1][3],__x,__L[1][1],'plus),
                       __M:matrix(["If",__x,"in",
                                   %if(is(equal(__L[1][1],__L[1][2])),"[",
                                       %if(is(equal(__L[1][1],'minf)),"(",
                                           _ls)),__L[1][1],",",__L[1][2],
                                   %if(is(equal(__L[1][1],__L[1][2])),"]",
                                       %if(is(equal(__L[1][2],'inf)),")",
                                           _rs)),"then",__L[1][3]]),
                       for __k from 2 thru length(__L) do
                           if listp(__L[__k])
                               then (if length(__L[__k]) = 3
                                         then (
                                         __L[__k+1][3]
                                          :__L[__k+1][3]
                                           +(if member('connect,__options)
                                                 then limit(__L[__k][3],__x,
                                                            __L[__k][2],
                                                            'minus)
                                                 -limit(__L[__k+1][3],__x,
                                                        __L[__k+1][1],'plus)
                                                 else 0),
                                         __M
                                          :addrow(__M,
                                                  ["If",__x,"in",
                                                   %if(
                                                    is(
                                                     equal(__L[__k][1],
                                                           __L[__k][2])),"[",
                                                    _ls),__L[__k][1],",",
                                                   __L[__k][2],
                                                   %if(
                                                    is(
                                                     equal(__L[__k][1],
                                                           __L[__k][2])),"]",
                                                    %if(
                                                     is(
                                                      equal(__L[__k][2],
                                                            'inf)),")",_rs)),
                                                   "then",__L[__k][3]]))))
                 elseif length(__L) > 2 and oddp(length(__L))
                 then (if member('connect,__options) and __L[1] # 'minf
                           then __L[2]:__L[2]-limit(__L[2],__x,__L[1],'plus),
                       __M:matrix(["If",__x,"in",
                                   %if(is(equal(__L[1],__L[3])),"[",
                                       %if(is(equal(__L[1],'minf)),"(",_ls)),
                                   __L[1],",",__L[3],
                                   %if(is(equal(__L[1],__L[3])),"]",_rs),
                                   "then",__L[2]]),
                       for __k from 2 step 2 thru length(__L)-3 do
                           (if member('connect,__options)
                                then __L[__k+2]
                                :__L[__k+2]
                                 +limit(__L[__k],__x,__L[__k+1],'minus)
                                 -limit(__L[__k+2],__x,__L[__k+1],'plus),
                            __M:addrow(__M,
                                       ["If",__x,"in",
                                        %if(is(equal(__L[__k+1],__L[__k+3])),
                                            "[",_ls),__L[__k+1],",",
                                        __L[__k+3],
                                        %if(is(equal(__L[__k+1],__L[__k+3])),
                                            "]",
                                            %if(is(equal(__L[__k+3],'inf)),
                                                ")",_rs)),"then",
                                        __L[__k+2]]))) elseif length(__L) = 1
                 then __M:matrix(["If",__x,"in","(",minf,",",inf,")","then",
                                  __L[1]])
                 else error("Error : List has an even number of terms and it is the simple type."),
             if __ans # 'inconsistent
                 then (if member('array,_options)
                           then (disp(" "),disp(__M),__ans:"Done")
                           elseif member('ifthen,__options)
                           then __ans:iif2ifthen(pwiifify(__M,_options))
                           elseif member('iif,__options)
                           then __ans:simp_iif(pwiifify(__M,_options))
                           elseif member('%if,__options)
                           then __ans:pw%ifify(__M,_options)
                           elseif member('between,__options)
                           then __ans:pwsumifybetween(__M,_options)
                           elseif member('pulse,__options)
                           then __ans:between2unitpulse(
                                      pwsumifybetween(__M,_options))
                           elseif member('signum,__options)
                           then __ans:pwsumifysignum(__M,_options)
                           elseif member('unitstep,__options)
                           then __ans:negunitstep(
                                      signum2unitstep(
                                       pwsumifysignum(__M,_options)),__x)
                           elseif member('abs,__options)
                           then __ans:signum2abs(pwsumifysignum(__M,_options))
                           elseif use_between = 'true
                           then __ans:pwsumifybetween(__M,_options)
                           elseif use_between = 'false
                           then __ans:pwsumifysignum(__M,_options)
                           elseif use_between = 'pulse
                           then __ans:between2unitpulse(
                                      pwsumifybetween(__M,_options))
                           else __ans:pwsumifysignum(__M,_options))
                 else [__ans])
       else error("First argument must be a list and not an empty list."));

/* Problem 32 (line 1262) */
piecewise(__L,__x,[__options]):=pw(__L,__x,__options);
/* Erroneous Result?:
piecewise(__L,__x,[__options]):=pw(__L,__x,__options) */ 
/* Expected result: */
pwsumifybetween(__M,[__options]):=block([__i,__retval:0,_option,_tmp:[]],
                __options:flatten(__options),
                if member('rclosed,__options) then _option:'rclosed
                    elseif member('open,__options) then _option:'open
                    elseif member('lclosed,__options) then _option:'lclosed
                    elseif member('closed,__options) then _option:'closed
                    elseif member('halfopen,__options) then _option:'halfopen
                    else _option:'none,
                if matrixp(__M) and length(__M[1]) = 10
                    then (for __i thru length(__M) do
                              if is(equal(__M[__i,5],__M[__i,7])) = true
                                   and listp(__M[__i,10])
                                  then __retval
                                  :__retval
                                   +(if length(__M[__i,10]) = 2
                                         then second(__M[__i,10])
                                         *diff_pwdelta(first(__M[__i,10]),
                                                       __M[__i,2]-__M[__i,5])
                                         elseif length(__M[__i,10]) = 1
                                          or length(__M[__i,10]) = 2
                                           and first(__M[__i,10]) = 0
                                         then first(__M[__i,10])
                                         *pwdelta(__M[__i,2]-__M[__i,5])
                                         else _tmp:'inconsistent)
                                  elseif is(equal(__M[__i,5],__M[__i,7]))
                                   = true
                                   and not listp(__M[__i,10])
                                  then __retval
                                  :__retval
                                   +__M[__i,10]
                                    *unit_spike(__M[__i,2]-__M[__i,5])
                                  elseif listp(__M[__i,10])
                                   and is(equal(__M[__i,5],__M[__i,7]))
                                    = false then __retval:['inconsistent]
                                  elseif not listp(__M[__i,10])
                                  then (if _option = 'none
                                            then __retval
                                            :__retval
                                             +__M[__i,10]
                                              *between(__M[__i,2],__M[__i,5],
                                                       __M[__i,7])
                                            else __retval
                                            :__retval
                                             +__M[__i,10]
                                              *between(__M[__i,2],__M[__i,5],
                                                       __M[__i,7],_option))
                                  else __retval:['inconsistent])
                    else error("This is not a user function."),
                if _tmp # 'inconsistent then __retval else [_tmp]);

/* Problem 33 (line 1393) */
pw%ifify(__M,[__options]):=block([__i,__retval:0,_option,_tmp:[]],
         __options:flatten(__options),
         if member('rclosed,__options) then _option:'rclosed
             elseif member('open,__options) then _option:'open
             elseif member('lclosed,__options) then _option:'lclosed
             elseif member('closed,__options) then _option:'closed
             elseif member('halfopen,__options) then _option:'halfopen
             else _option:'none,
         if matrixp(__M) and length(__M[1]) = 10
             then (for __i thru length(__M) do
                       if is(equal(__M[__i,5],__M[__i,7])) = true
                            and listp(__M[__i,10])
                           then __retval
                           :__retval+(if length(__M[__i,10]) = 2
                                          then second(__M[__i,10])
                                          *diff_pwdelta(first(__M[__i,10]),
                                                        __M[__i,2]-__M[__i,5])
                                          elseif length(__M[__i,10]) = 1
                                           or length(__M[__i,10]) = 2
                                            and first(__M[__i,10]) = 0
                                          then first(__M[__i,10])
                                          *pwdelta(__M[__i,2]-__M[__i,5])
                                          else _tmp:'inconsistent)
                           elseif is(equal(__M[__i,5],__M[__i,7])) = true
                            and not listp(__M[__i,10])
                           then __retval
                           :__retval+__M[__i,10]
                                     *unit_spike(__M[__i,2]-__M[__i,5])
                           elseif listp(__M[__i,10])
                            and is(equal(__M[__i,5],__M[__i,7])) = false
                           then __retval:['inconsistent]
                           elseif not listp(__M[__i,10])
                           then (if _option = 'closed
                                     then __retval
                                     :__retval
                                      +%if(__M[__i,2] >= __M[__i,5],
                                           %if(__M[__i,2] <= __M[__i,7],
                                               __M[__i,10],0),0)
                                     elseif _option = 'lclosed
                                     then __retval
                                     :__retval
                                      +%if(__M[__i,2] >= __M[__i,5],
                                           %if(__M[__i,2] < __M[__i,7],
                                               __M[__i,10],0),0)
                                     elseif _option = 'rclosed
                                     then __retval
                                     :__retval
                                      +%if(__M[__i,2] > __M[__i,5],
                                           %if(__M[__i,2] <= __M[__i,7],
                                               __M[__i,10],0),0)
                                     elseif _option = 'open
                                     then __retval
                                     :__retval
                                      +%if(__M[__i,2] > __M[__i,5],
                                           %if(__M[__i,2] < __M[__i,7],
                                               __M[__i,10],0),0)
                                     elseif _option = 'halfopen
                                     then __retval
                                     :__retval
                                      +%if(__M[__i,2] > __M[__i,5],
                                           %if(__M[__i,2] < __M[__i,7],
                                               __M[__i,10],
                                               %if(__M[__i,2] = __M[__i,7],
                                                   __M[__i,10]/2,0)),
                                           %if(__M[__i,2] = __M[__i,5],
                                               __M[__i,10]/2,0))
                                     else __retval
                                     :__retval
                                      +%if(__M[__i,2] > __M[__i,5],
                                           %if(__M[__i,2] < __M[__i,7],
                                               __M[__i,10],
                                               %if(__M[__i,2] = __M[__i,7],
                                                   __M[__i,10]/2,0)),
                                           %if(__M[__i,2] = __M[__i,5],
                                               __M[__i,10]/2,0)))
                           else __retval:['inconsistent])
             else error("This is not a user function."),
         if _tmp # 'inconsistent then __retval else [_tmp]);
/* Erroneous Result?:
pw%ifify(__M,[__options]):=block([__i,__retval:0,_option,_tmp:[]],
         __options:flatten(__options),
         if member('rclosed,__options) then _option:'rclosed
             elseif member('open,__options) then _option:'open
             elseif member('lclosed,__options) then _option:'lclosed
             elseif member('closed,__options) then _option:'closed
             elseif member('halfopen,__options) then _option:'halfopen
             else _option:'none,
         if matrixp(__M) and length(__M[1]) = 10
             then (for __i thru length(__M) do
                       if is(equal(__M[__i,5],__M[__i,7])) = true
                            and listp(__M[__i,10])
                           then __retval
                           :__retval+(if length(__M[__i,10]) = 2
                                          then second(__M[__i,10])
                                          *diff_pwdelta(first(__M[__i,10]),
                                                        __M[__i,2]-__M[__i,5])
                                          elseif length(__M[__i,10]) = 1
                                           or length(__M[__i,10]) = 2
                                            and first(__M[__i,10]) = 0
                                          then first(__M[__i,10])
                                          *pwdelta(__M[__i,2]-__M[__i,5])
                                          else _tmp:'inconsistent)
                           elseif is(equal(__M[__i,5],__M[__i,7])) = true
                            and not listp(__M[__i,10])
                           then __retval
                           :__retval+__M[__i,10]
                                     *unit_spike(__M[__i,2]-__M[__i,5])
                           elseif listp(__M[__i,10])
                            and is(equal(__M[__i,5],__M[__i,7])) = false
                           then __retval:['inconsistent]
                           elseif not listp(__M[__i,10])
                           then (if _option = 'closed
                                     then __retval
                                     :__retval
                                      +%if(__M[__i,2] >= __M[__i,5],
                                           %if(__M[__i,2] <= __M[__i,7],
                                               __M[__i,10],0),0)
                                     elseif _option = 'lclosed
                                     then __retval
                                     :__retval
                                      +%if(__M[__i,2] >= __M[__i,5],
                                           %if(__M[__i,2] < __M[__i,7],
                                               __M[__i,10],0),0)
                                     elseif _option = 'rclosed
                                     then __retval
                                     :__retval
                                      +%if(__M[__i,2] > __M[__i,5],
                                           %if(__M[__i,2] <= __M[__i,7],
                                               __M[__i,10],0),0)
                                     elseif _option = 'open
                                     then __retval
                                     :__retval
                                      +%if(__M[__i,2] > __M[__i,5],
                                           %if(__M[__i,2] < __M[__i,7],
                                               __M[__i,10],0),0)
                                     elseif _option = 'halfopen
                                     then __retval
                                     :__retval
                                      +%if(__M[__i,2] > __M[__i,5],
                                           %if(__M[__i,2] < __M[__i,7],
                                               __M[__i,10],
                                               %if(__M[__i,2] = __M[__i,7],
                                                   __M[__i,10]/2,0)),
                                           %if(__M[__i,2] = __M[__i,5],
                                               __M[__i,10]/2,0))
                                     else __retval
                                     :__retval
                                      +%if(__M[__i,2] > __M[__i,5],
                                           %if(__M[__i,2] < __M[__i,7],
                                               __M[__i,10],
                                               %if(__M[__i,2] = __M[__i,7],
                                                   __M[__i,10]/2,0)),
                                           %if(__M[__i,2] = __M[__i,5],
                                               __M[__i,10]/2,0)))
                           else __retval:['inconsistent])
             else error("This is not a user function."),
         if _tmp # 'inconsistent then __retval else [_tmp]) */ 
/* Expected result: */
pwiifify(__M,[__options]):=block([__i,__retval:0,_option,_tmp:[]],
         __options:flatten(__options),
         if member('rclosed,__options) then _option:'rclosed
             elseif member('open,__options) then _option:'open
             elseif member('lclosed,__options) then _option:'lclosed
             elseif member('closed,__options) then _option:'closed
             elseif member('halfopen,__options) then _option:'halfopen
             else _option:'none,
         if matrixp(__M) and length(__M[1]) = 10
             then (for __i thru length(__M) do
                       if is(equal(__M[__i,5],__M[__i,7])) = true
                            and listp(__M[__i,10])
                           then __retval
                           :__retval+(if length(__M[__i,10]) = 2
                                          then second(__M[__i,10])
                                          *diff_pwdelta(first(__M[__i,10]),
                                                        __M[__i,2]-__M[__i,5])
                                          elseif length(__M[__i,10]) = 1
                                           or length(__M[__i,10]) = 2
                                            and first(__M[__i,10]) = 0
                                          then first(__M[__i,10])
                                          *pwdelta(__M[__i,2]-__M[__i,5])
                                          else _tmp:'inconsistent)
                           elseif is(equal(__M[__i,5],__M[__i,7])) = true
                            and not listp(__M[__i,10])
                           then __retval
                           :__retval+__M[__i,10]
                                     *iif(equal(__M[__i,2],__M[__i,5]),1,0)
                           elseif listp(__M[__i,10])
                            and is(equal(__M[__i,5],__M[__i,7])) = false
                           then __retval:['inconsistent]
                           elseif not listp(__M[__i,10])
                           then (if _option = 'closed
                                     then __retval
                                     :__retval
                                      +iif(__M[__i,2] >= __M[__i,5],
                                           iif(__M[__i,2] <= __M[__i,7],
                                               __M[__i,10],0),0)
                                     elseif _option = 'lclosed
                                     then __retval
                                     :__retval
                                      +iif(__M[__i,2] >= __M[__i,5],
                                           iif(__M[__i,2] < __M[__i,7],
                                               __M[__i,10],0),0)
                                     elseif _option = 'rclosed
                                     then __retval
                                     :__retval
                                      +iif(__M[__i,2] > __M[__i,5],
                                           iif(__M[__i,2] <= __M[__i,7],
                                               __M[__i,10],0),0)
                                     elseif _option = 'open
                                     then __retval
                                     :__retval
                                      +iif(__M[__i,2] > __M[__i,5],
                                           iif(__M[__i,2] < __M[__i,7],
                                               __M[__i,10],0),0)
                                     elseif _option = 'halfopen
                                     then __retval
                                     :__retval
                                      +iif(__M[__i,2] > __M[__i,5],
                                           iif(__M[__i,2] < __M[__i,7],
                                               __M[__i,10],
                                               iif(
                                                equal(__M[__i,2],__M[__i,7]),
                                                __M[__i,10]/2,0)),
                                           iif(equal(__M[__i,2],__M[__i,5]),
                                               __M[__i,10]/2,0))
                                     else __retval
                                     :__retval
                                      +iif(__M[__i,2] > __M[__i,5],
                                           iif(__M[__i,2] < __M[__i,7],
                                               __M[__i,10],
                                               iif(
                                                equal(__M[__i,2],__M[__i,7]),
                                                __M[__i,10]/2,0)),
                                           iif(equal(__M[__i,2],__M[__i,5]),
                                               __M[__i,10]/2,0)))
                           else __retval:['inconsistent])
             else error("This is not a user function."),
         if _tmp # 'inconsistent then __retval else [_tmp]);

/* Problem 34 (line 1521) */
pwsumifysignum(__M,[options]):=block(
               [__i,__retval:0,__num1:0,__num2:0,_options,_tmp:[]],
               _options:flatten(options),
               if member('lclosed,_options) then (__num1:-1,__num2:-1)
                   elseif member('open,_options) then (__num1:1,__num2:-1)
                   elseif member('rclosed,_options) then (__num1:1,__num2:1)
                   elseif member('closed,_options) then (__num1:-1,__num2:1)
                   else (__num1:0,__num2:0),
               if matrixp(__M) and length(__M[1]) = 10
                   then (for __i thru length(__M) do
                             if is(equal(__M[__i,5],__M[__i,7])) = true
                                  and listp(__M[__i,10])
                                 then __retval
                                 :__retval
                                  +(if length(__M[__i,10]) = 2
                                        then second(__M[__i,10])
                                        *diff_pwdelta(first(__M[__i,10]),
                                                      __M[__i,2]-__M[__i,5])
                                        elseif length(__M[__i,10]) = 1
                                         or length(__M[__i,10]) = 2
                                          and first(__M[__i,10]) = 0
                                        then first(__M[__i,10])
                                        *pwdelta(__M[__i,2]-__M[__i,5])
                                        else (_tmp:'inconsistent,0))
                                 elseif is(equal(__M[__i,5],__M[__i,7]))
                                  = true
                                  and not listp(__M[__i,10])
                                 then __retval
                                 :__retval
                                  +__M[__i,10]
                                   *unit_spike(__M[__i,2]-__M[__i,5])
                                 elseif listp(__M[__i,10])
                                  and is(equal(__M[__i,5],__M[__i,7])) = false
                                 then __retval:['inconsistent]
                                 elseif not listp(__M[__i,10])
                                 then __retval
                                 :__retval
                                  +(((__M[__i,10]
                                   *(1+signum(__M[__i,7]-__M[__i,5])))
                                   *(signum(__M[__i,2]-__M[__i,5])
                                    -signum(__M[__i,2]-__M[__i,7])
                                    +signum(__M[__i,5]-__M[__i,7])
                                     *__num1*unit_spike(__M[__i,2]-__M[__i,5])
                                    -signum(__M[__i,5]-__M[__i,7])
                                     *__num2
                                     *unit_spike(__M[__i,2]-__M[__i,7])))
                                   /2)
                                   /2 else __retval:['inconsistent])
                   else error("This is not a user function."),
               if _tmp # 'inconsistent then __retval else [_tmp]);
/* Erroneous Result?:
pwsumifysignum(__M,[options]):=block(
               [__i,__retval:0,__num1:0,__num2:0,_options,_tmp:[]],
               _options:flatten(options),
               if member('lclosed,_options) then (__num1:-1,__num2:-1)
                   elseif member('open,_options) then (__num1:1,__num2:-1)
                   elseif member('rclosed,_options) then (__num1:1,__num2:1)
                   elseif member('closed,_options) then (__num1:-1,__num2:1)
                   else (__num1:0,__num2:0),
               if matrixp(__M) and length(__M[1]) = 10
                   then (for __i thru length(__M) do
                             if is(equal(__M[__i,5],__M[__i,7])) = true
                                  and listp(__M[__i,10])
                                 then __retval
                                 :__retval
                                  +(if length(__M[__i,10]) = 2
                                        then second(__M[__i,10])
                                        *diff_pwdelta(first(__M[__i,10]),
                                                      __M[__i,2]-__M[__i,5])
                                        elseif length(__M[__i,10]) = 1
                                         or length(__M[__i,10]) = 2
                                          and first(__M[__i,10]) = 0
                                        then first(__M[__i,10])
                                        *pwdelta(__M[__i,2]-__M[__i,5])
                                        else (_tmp:'inconsistent,0))
                                 elseif is(equal(__M[__i,5],__M[__i,7]))
                                  = true
                                  and not listp(__M[__i,10])
                                 then __retval
                                 :__retval
                                  +__M[__i,10]
                                   *unit_spike(__M[__i,2]-__M[__i,5])
                                 elseif listp(__M[__i,10])
                                  and is(equal(__M[__i,5],__M[__i,7])) = false
                                 then __retval:['inconsistent]
                                 elseif not listp(__M[__i,10])
                                 then __retval
                                 :__retval
                                  +(((__M[__i,10]
                                   *(1+signum(__M[__i,7]-__M[__i,5])))
                                   *(signum(__M[__i,2]-__M[__i,5])
                                    -signum(__M[__i,2]-__M[__i,7])
                                    +signum(__M[__i,5]-__M[__i,7])
                                     *__num1*unit_spike(__M[__i,2]-__M[__i,5])
                                    -signum(__M[__i,5]-__M[__i,7])
                                     *__num2
                                     *unit_spike(__M[__i,2]-__M[__i,7])))
                                   /2)
                                   /2 else __retval:['inconsistent])
                   else error("This is not a user function."),
               if _tmp # 'inconsistent then __retval else [_tmp]) */ 
/* Expected result: */
pwifify(__M,[__options]):=block(
        [__i,__retval,_L1:[],__num1:0,__num2:0,_options,_tmp:[]],
        _options:flatten(__options),
        if matrixp(__M) and length(__M[1]) = 10
            then (for __i thru length(__M) do
                      if is(equal(__M[__i,5],__M[__i,7])) = true
                           and listp(__M[__i,10])
                          then (if length(__M[__i,10]) = 2
                                    then _L1
                                    :append(_L1,
                                            [equal(__M[__i,2],__M[__i,5])],
                                            [
                                             second(__M[__i,10])
                                              *diff_pwdelta(
                                               first(__M[__i,10]),
                                               __M[__i,2]-__M[__i,5])])
                                    elseif length(__M[__i,10]) = 1
                                     or length(__M[__i,10]) = 2
                                      and first(__M[__i,10]) = 0
                                    then _L1
                                    :append(_L1,
                                            [equal(__M[__i,2],__M[__i,5])],
                                            [
                                             first(__M[__i,10])
                                              *pwdelta(
                                               __M[__i,2]-__M[__i,5])])
                                    else _tmp:'inconsistent)
                          elseif is(equal(__M[__i,5],__M[__i,7])) = true
                           and not listp(__M[__i,10])
                          then _L1:append(_L1,[equal(__M[__i,2],__M[__i,5])],
                                          [
                                           __M[__i,10]
                                            *unit_spike(
                                             __M[__i,2]-__M[__i,5])])
                          elseif listp(__M[__i,10])
                           and is(equal(__M[__i,5],__M[__i,7])) = false
                          then __retval:['inconsistent]
                          elseif not listp(__M[__i,10])
                          then (if member('lclosed,_options)
                                    then _L1
                                    :append(_L1,
                                            [
                                             between(__M[__i,2],__M[__i,5],
                                                     __M[__i,7],'lclosed)
                                               > 0],[__M[__i,10]])
                                    elseif member('open,_options)
                                    then _L1
                                    :append(_L1,
                                            [
                                             between(__M[__i,2],__M[__i,5],
                                                     __M[__i,7],'open)
                                               > 0],[__M[__i,10]])
                                    elseif member('rclosed,_options)
                                    then _L1
                                    :append(_L1,
                                            [
                                             between(__M[__i,2],__M[__i,5],
                                                     __M[__i,7],'rclosed)
                                               > 0],[__M[__i,10]])
                                    elseif member('closed,_options)
                                    then _L1
                                    :append(_L1,
                                            [
                                             between(__M[__i,2],__M[__i,5],
                                                     __M[__i,7],'closed)
                                               > 0],[__M[__i,10]])
                                    else _L1
                                    :append(_L1,
                                            [
                                             between(__M[__i,2],__M[__i,5],
                                                     __M[__i,7])
                                               > 0],[__M[__i,10]]))
                          else __retval:['inconsistent],
                  _L1:append(_L1,[true],[0]),__retval:apply("if",_L1))
            else error("This is not a user function."),
        if _tmp # 'inconsistent then __retval else [_tmp]);

/* Problem 35 (line 1617) */
simpsignum(__e):=block([opsubst:true,inflag:true],
           subst('signum = lambda([_z],
                                  block([_s,_e,_t],_t:1,_s:factor(_z),
                                        if not mapatom(_s) and op(_s) = "*"
                                            then (for _e in _s do
                                                      if 
                                                      not mapatom(_e)
                                                        and op(_e) = "^"
                                                       then _t
                                                       :signum(
                                                        first(
                                                         first(
                                                          gatherargs(
                                                           _e,"^"))))
                                                        ^second(
                                                         first(
                                                          gatherargs(_e,"^")))
                                                        *_t
                                                       else _t:signum(_e)*_t)
                                            elseif not mapatom(_s)
                                             and op(_s) = "^"
                                            then _t
                                            :signum(
                                             first(first(gatherargs(_s,"^"))))
                                             ^second(
                                              first(gatherargs(_s,"^")))
                                            else _t:signum(_s),_t)),__e));
/* Erroneous Result?:
simpsignum(__e):=block([opsubst:true,inflag:true],
           subst('signum = lambda([_z],
                                  block([_s,_e,_t],_t:1,_s:factor(_z),
                                        if not mapatom(_s) and op(_s) = "*"
                                            then (for _e in _s do
                                                      if 
                                                      not mapatom(_e)
                                                        and op(_e) = "^"
                                                       then _t
                                                       :signum(
                                                        first(
                                                         first(
                                                          gatherargs(
                                                           _e,"^"))))
                                                        ^second(
                                                         first(
                                                          gatherargs(_e,"^")))
                                                        *_t
                                                       else _t:signum(_e)*_t)
                                            elseif not mapatom(_s)
                                             and op(_s) = "^"
                                            then _t
                                            :signum(
                                             first(first(gatherargs(_s,"^"))))
                                             ^second(
                                              first(gatherargs(_s,"^")))
                                            else _t:signum(_s),_t)),__e)) */ 
/* Expected result: */
simpsignumargs(__e,__x):=block([opsubst:true],
               subst('signum = lambda([__s],
                                      block([_t,_rv,_err,_start:1,_p],
                                            _t:linearfunc(__s,__x),
                                            if listp(_t) and is(first(_t) # 0)
                                                then _rv
                                                :signum(first(_t))
                                                 *signum(
                                                  __x+second(_t)/first(_t))
                                                else (_rv:signum(__s),
                                                      _t
                                                       :quadraticfunc(
                                                        __s,__x),
                                                      if 
                                                       listp(_t)
                                                         and is(first(_t) # 0)
                                                         and is(
                                                         second(_t)^2
                                                          -4*first(_t)
                                                            *third(_t)
                                                           > 0)
                                                        then _rv
                                                        :signum(
                                                         __x
                                                          -((-second(_t))
                                                           +sqrt(
                                                            second(_t)^2
                                                             -4*first(_t)
                                                               *third(_t)))
                                                           /(2*first(_t)))
                                                         *signum(
                                                          __x
                                                           -((-second(_t))
                                                            -sqrt(
                                                             second(_t)^2
                                                              -4*first(_t)
                                                                *third(_t)))
                                                            /(2*first(_t)))
                                                        elseif listp(_t)
                                                         and is(first(_t) # 0)
                                                         and is(
                                                         equal(
                                                          second(_t)^2
                                                           -4*first(_t)
                                                             *third(_t),0))
                                                        then _rv
                                                        :at(signum(__s),
                                                            [
                                                             __x
                                                               = ((-second(
                                                               _t))
                                                               +sqrt(
                                                                second(_t)^2
                                                                 -4*first(_t)
                                                                   *third(
                                                                    _t)))
                                                               /(2*first(_t))
                                                               +1])
                                                         -unit_spike(
                                                          __x
                                                           -(-second(_t))
                                                            /(2*first(_t)))
                                                        elseif listp(_t)
                                                         and is(first(_t) # 0)
                                                         and is(
                                                         second(_t)^2
                                                          -4*first(_t)
                                                            *third(_t)
                                                           < 0)
                                                          = true
                                                        then _rv
                                                        :at(signum(__s),
                                                            __x = 0)
                                                        else (
                                                        _err
                                                         :errcatch(
                                                          _t:realroots(__s)),
                                                        if _err # []
                                                            then (
                                                            for _p in _t do
                                                                _start
                                                                :signum(
                                                                 __x-rhs(_p))
                                                                 *_start,
                                                            _rv:_start)
                                                            else _rv
                                                            :signum(__s))),
                                            _rv)),__e));

/* Problem 36 (line 1694) */
negunitstep(__e,__x):=block([opsubst:true,inflag:true],
            subst('unit_step = lambda([s],
                                      block([_t],_t:linearfunc(s,__x),
                                            if listp(_t) and first(_t) < 0
                                                then 1-unit_step(-s)
                                                      -unit_spike(-s)
                                                else unit_step(s))),__e));
/* Erroneous Result?:
negunitstep(__e,__x):=block([opsubst:true,inflag:true],
            subst('unit_step = lambda([s],
                                      block([_t],_t:linearfunc(s,__x),
                                            if listp(_t) and first(_t) < 0
                                                then 1-unit_step(-s)
                                                      -unit_spike(-s)
                                                else unit_step(s))),__e)) */ 
/* Expected result: */
simpunitstep(__e,__x):=block(
             [inflag:true,_cnt:0,_args:[],_ans,_roots1:[],_roots2:[],_maxval,
              _minval,__retval:0,_tmp],
             __e:expandwrt(__e,'unit_step,'signum,'pwdelta,'diff_pwdelta),
             if not mapatom(__e) and safe_op(__e) = "*"
                 then (if length(gatherargs(__e,'unit_step)) > 1
                           then (__retval:1,
                                 for lk in __e do
                                     if 
                                     not mapatom(lk) and op(lk) = 'unit_step
                                      then (
                                      _args:first(gatherargs(lk,'unit_step)),
                                      _ans:linearfunc(first(_args),__x),
                                      if listp(_ans)
                                          then (if first(_ans) > 0
                                                    then _roots1
                                                    :cons(
                                                     (-second(_ans))
                                                      /first(_ans),_roots1)
                                                    elseif first(_ans) < 0
                                                    then _roots2
                                                    :cons(
                                                     (-second(_ans))
                                                      /first(_ans),_roots2)
                                                    else __retval:__retval*lk)
                                          else __retval:__retval*lk)
                                      elseif not mapatom(lk) and op(lk) = "^"
                                      then (_tmp:simpunitstep(lk,__x),
                                            if 
                                             not mapatom(_tmp)
                                               and op(_tmp) = 'unit_step
                                              then (
                                              _args
                                               :first(
                                                gatherargs(_tmp,'unit_step)),
                                              _ans
                                               :linearfunc(first(_args),__x),
                                              if listp(_ans)
                                                  then (if first(_ans) > 0
                                                            then _roots1
                                                            :cons(
                                                             (-second(_ans))
                                                              /first(_ans),
                                                             _roots1)
                                                            elseif first(_ans)
                                                             < 0
                                                            then _roots2
                                                            :cons(
                                                             (-second(_ans))
                                                              /first(_ans),
                                                             _roots2)
                                                            else __retval
                                                            :__retval*lk)
                                                  else __retval:__retval*lk)
                                              else __retval:__retval*lk)
                                      else __retval:__retval*lk,
                                 _maxval:apply('max,_roots1),
                                 _minval:apply('min,_roots2),
                                 __retval
                                  :__retval*unit_step(__x-_maxval)
                                           *unit_step((-__x)+_minval))
                           elseif not mapatom(__e) and op(__e) = "^"
                           then __retval:simpunitstep(__e,__x)
                           else __retval:__e)
                 elseif not mapatom(__e) and safe_op(__e) = "+"
                 then (for lk in __e do
                           __retval:simpunitstep(lk,__x)+__retval)
                 else __retval:__e,__retval);

/* Problem 37 (line 1780) */
periodic(__expr,__x,__a,__b):=block(
         if not is(__b > __a) = false
             then subst(__x-__a,__x,
                        subst((__b-__a)*(__x/(__b-__a)-floor(__x/(__b-__a)))
                               +__a,__x,__expr)) else error("a>b"));
/* Erroneous Result?:
periodic(__expr,__x,__a,__b):=block(
         if not is(__b > __a) = false
             then subst(__x-__a,__x,
                        subst((__b-__a)*(__x/(__b-__a)-floor(__x/(__b-__a)))
                               +__a,__x,__expr)) else error("a>b")) */ 
/* Expected result: */
intperiodic(__expr,__x,__a,__b):=block(
            if not is(__b > __a) = false
                then (((__x-__a)-(__b-__a)
                                 *((__x-__a)/(__b-__a)
                                  -floor((__x-__a)/(__b-__a))))
                /(__b-__a))
                *pwint(__expr,__x,__a,__b)
                +periodic(pwint(__expr,__x),__x,__a,__b) else error("a>b"));

/* Problem 38 (line 1842) */
pwdefint(__e,__x,__a,__b):=block(
         [_s,_ans,_c,_d,_p,_t,_done:false,algebraic:true],_s:pwint(__e,__x),
         if freeof(__x,__e) then _ans:__e*(__b-__a)
             elseif freeof('integrate,_s) and freeof('pwint,_s)
             then (_t:errcatch(_ans:at(_s,[__x = __b])-at(_s,[__x = __a])),
                   if _t = []
                       then _ans:funmake(nounify('integrate),
                                         [__e,__x,__a,__b])
                       else (if freeof('und,'inf,'minf,_ans)
                                 then (_ans,_done:true),
                             if not _done
                                  and not freeof('und,'inf,'minf,'signum,
                                                 'between,_ans)
                                 then (_ans:ratsimp(_ans),
                                       if not freeof('und,'inf,'minf,_ans)
                                           then _done:false else _done:true),
                             if not _done and (__b = 'inf or __a = 'minf)
                                 then (if __b = 'inf and __a = 'minf
                                           then _ans
                                           :pwlimit(
                                            pwlimit(
                                             at(_s,[__x = _d])
                                              -at(_s,[__x = _c]),_d,'inf),_c,
                                            'minf) elseif __b = 'inf
                                           then _ans
                                           :pwlimit(
                                            at(_s,[__x = _d])
                                             -at(_s,[__x = __a]),_d,'inf)
                                           elseif __a = 'minf
                                           then _ans
                                           :pwlimit(
                                            at(_s,[__x = __b])
                                             -at(_s,[__x = _c]),_c,'minf)
                                           else _ans)))
             else _ans:funmake(nounify('integrate),[__e,__x,__a,__b]),_ans);
/* Erroneous Result?:
pwdefint(__e,__x,__a,__b):=block(
         [_s,_ans,_c,_d,_p,_t,_done:false,algebraic:true],_s:pwint(__e,__x),
         if freeof(__x,__e) then _ans:__e*(__b-__a)
             elseif freeof('integrate,_s) and freeof('pwint,_s)
             then (_t:errcatch(_ans:at(_s,[__x = __b])-at(_s,[__x = __a])),
                   if _t = []
                       then _ans:funmake(nounify('integrate),
                                         [__e,__x,__a,__b])
                       else (if freeof('und,'inf,'minf,_ans)
                                 then (_ans,_done:true),
                             if not _done
                                  and not freeof('und,'inf,'minf,'signum,
                                                 'between,_ans)
                                 then (_ans:ratsimp(_ans),
                                       if not freeof('und,'inf,'minf,_ans)
                                           then _done:false else _done:true),
                             if not _done and (__b = 'inf or __a = 'minf)
                                 then (if __b = 'inf and __a = 'minf
                                           then _ans
                                           :pwlimit(
                                            pwlimit(
                                             at(_s,[__x = _d])
                                              -at(_s,[__x = _c]),_d,'inf),_c,
                                            'minf) elseif __b = 'inf
                                           then _ans
                                           :pwlimit(
                                            at(_s,[__x = _d])
                                             -at(_s,[__x = __a]),_d,'inf)
                                           elseif __a = 'minf
                                           then _ans
                                           :pwlimit(
                                            at(_s,[__x = __b])
                                             -at(_s,[__x = _c]),_c,'minf)
                                           else _ans)))
             else _ans:funmake(nounify('integrate),[__e,__x,__a,__b]),_ans) */ 
/* Expected result: */
pwlimit(__e,__x,__value):=block(
        [inflag:true,_tmp,__retval:0,_q,_args,_thelim],
        if is(__value = 'inf) = true or is(__value = 'minf) = true
            then (__retval:iif2sum(abs2iif(between2iif(__e))),
                  _args:flatten(gatherargs(__retval,'signum)),
                  while length(_args) > 0 do
                        (_q:first(_args),_args:rest(_args),
                         if numberp(polydeg(_q,__x))
                             then (_thelim:polysignum(_q,__x,__value),
                                   __retval
                                    :subst(_thelim,signum(_q),__retval))),
                  __retval:facsum(__retval,__x),
                  if safe_op(__retval) = "*" and not freeof('signum,__retval)
                      then (_tmp:xreduce("*",
                                         sublist(args(__retval),
                                                 lambda([_arg],
                                                        freeof(__x,_arg)))),
                            __retval:_tmp*limit(__retval/_tmp,__x,__value))
                      else __retval:apply('simp_given,
                                          cons(limit(__retval,__x,__value),
                                               map(
                                                lambda([_s],
                                                       if __value = 'inf
                                                           then __x > _s
                                                           else __x < _s),
                                                listofvars(__retval)))))
            else error("Third argument must be inf or minf."),__retval);

/* Problem 39 (line 1908) */
polysignum(__p,__x,__value):=block([_p,_degree:polydeg(__p,__x),_sign_x],
           if __value < 0 then _sign_x:-1 else _sign_x:1,
           if numberp(_degree) and _degree # false
               then (if is(equal(_degree,0)) = true then signum(__p)
                         elseif is(oddp(_degree)) = true
                         then (_p:__p-ratcoef(__p,__x,_degree)*__x^_degree,
                               _sign_x*signum(ratcoef(__p,__x,_degree))
                                +unit_spike(ratcoef(__p,__x,_degree))
                                 *polysignum(_p,__x,__value))
                         elseif is(evenp(_degree)) = true
                         then (_p:__p-ratcoef(__p,__x,_degree)*__x^_degree,
                               signum(ratcoef(__p,__x,_degree))
                                +unit_spike(ratcoef(__p,__x,_degree))
                                 *polysignum(_p,__x,__value))
                         else signum(__p)) else signum(__p));
/* Erroneous Result?:
polysignum(__p,__x,__value):=block([_p,_degree:polydeg(__p,__x),_sign_x],
           if __value < 0 then _sign_x:-1 else _sign_x:1,
           if numberp(_degree) and _degree # false
               then (if is(equal(_degree,0)) = true then signum(__p)
                         elseif is(oddp(_degree)) = true
                         then (_p:__p-ratcoef(__p,__x,_degree)*__x^_degree,
                               _sign_x*signum(ratcoef(__p,__x,_degree))
                                +unit_spike(ratcoef(__p,__x,_degree))
                                 *polysignum(_p,__x,__value))
                         elseif is(evenp(_degree)) = true
                         then (_p:__p-ratcoef(__p,__x,_degree)*__x^_degree,
                               signum(ratcoef(__p,__x,_degree))
                                +unit_spike(ratcoef(__p,__x,_degree))
                                 *polysignum(_p,__x,__value))
                         else signum(__p)) else signum(__p)) */ 
/* Expected result: */
polydeg(__p,__x):=block([_deg:-1,_okay,_ans],
        _okay:polynomialp(__p,[__x],lambda([_l],freeof(__x,_l)),
                          lambda([_l],nonnegintegerp(_l))),
        if _okay then _deg:hipow(__p,__x));

/* Problem 40 (line 1925) */
zerospikes(__e):=block([opsubst:true],subst('unit_spike = lambda([z],0),__e));
/* Erroneous Result?:
zerospikes(__e):=block([opsubst:true],subst('unit_spike = lambda([z],0),__e)) */ 
/* Expected result: */
zeropwdeltas(__e):=block([opsubst:true],subst('pwdelta = lambda([z],0),__e));

/* Problem 41 (line 1927) */
zerodiffpwdeltas(__e):=block([opsubst:true],
                 subst('diff_pwdelta = lambda([z1,z2],0),__e));
/* Erroneous Result?:
zerodiffpwdeltas(__e):=block([opsubst:true],
                 subst('diff_pwdelta = lambda([z1,z2],0),__e)) */ 
/* Expected result: */
zeropwdeltas(__e):=zeropwdeltas(zerodiffpwdeltas(__e));

/* Problem 42 (line 1936) */
convertall2signum(__ex):=block(__ex:maxmin2abs(__ex),__ex:abs2signum(__ex),
                  __ex:unitpulse2signum(__ex),__ex:unitstep2signum(__ex),
                  __ex:simpsignum(__ex));
/* Erroneous Result?:
convertall2signum(__ex):=block(__ex:maxmin2abs(__ex),__ex:abs2signum(__ex),
                  __ex:unitpulse2signum(__ex),__ex:unitstep2signum(__ex),
                  __ex:simpsignum(__ex)) */ 
/* Expected result: */
signum2abs(__e):=block([__l],__e:simpsignum(__e),
           __l:flatten(gatherargs(__e,'signum)),
           for lk in __l do __e:ratsubst(abs(lk)/lk,signum(lk),__e),__e);

/* Problem 43 (line 1958) */
deltaint(__e,__x,[__v]):=block([inflag:true],
         if length(__v) = 0
             then zerospikes(negunitstep(signum2unitstep(pwint(__e,__x)),__x))
             elseif length(__v) = 2 then apply('pwint,flatten([__e,__x,__v]))
             else print("wrong number of arguments to deltaint"));
/* Erroneous Result?:
deltaint(__e,__x,[__v]):=block([inflag:true],
         if length(__v) = 0
             then zerospikes(negunitstep(signum2unitstep(pwint(__e,__x)),__x))
             elseif length(__v) = 2 then apply('pwint,flatten([__e,__x,__v]))
             else print("wrong number of arguments to deltaint")) */ 
/* Expected result: */
zeroconstterms(__e,__x):=block([inflag:true],
               if not mapatom(__e) and op(__e) = "+"
                   then xreduce("+",
                                sublist(args(__e),
                                        lambda([z],not freeof(__x,z))))
                   else __e);

/* Problem 44 (line 1971) */
max2abs(__e):=block([opsubst:true],
        subst('max = lambda([[__x]],
                            xreduce(lambda([_%a,_%b],
                                           (_%a+_%b+abs(_%a-_%b))/2),__x)),
              __e));
/* Erroneous Result?:
max2abs(__e):=block([opsubst:true],
        subst('max = lambda([[__x]],
                            xreduce(lambda([_%a,_%b],
                                           (_%a+_%b+abs(_%a-_%b))/2),__x)),
              __e)) */ 
/* Expected result: */
min2abs(__e):=block([opsubst:true],
        subst('min = lambda([[__x]],
                            xreduce(lambda([_%a,_%b],
                                           (_%a+_%b-abs(_%a-_%b))/2),__x)),
              __e));

/* Problem 45 (line 1973) */
maxmin2abs(__e):=max2abs(min2abs(__e));
/* Erroneous Result?:
maxmin2abs(__e):=max2abs(min2abs(__e)) */ 
/* Expected result: */
between2signum(__e):=block([opsubst:true],
               subst('between = lambda([__x,__a,__b,__o],
                                       (((1+signum(__b-__a))/2)
                                        *(signum(__x-__a)-signum(__x-__b)))
                                        /2),__e));

/* Problem 46 (line 1977) */
between2unitstep(__e):=block([opsubst:true],
                 subst('between = lambda([__x,__a,__b,__o],
                                         unit_step(__x-__a)
                                          -unit_step(__x-__b)),__e));
/* Erroneous Result?:
between2unitstep(__e):=block([opsubst:true],
                 subst('between = lambda([__x,__a,__b,__o],
                                         unit_step(__x-__a)
                                          -unit_step(__x-__b)),__e)) */ 
/* Expected result: */
charfun2signum(__e):=block([opsubst:true],
               subst('charfun2 = lambda([__x,__a,__b],
                                        (signum(__x-__a)-signum(__x-__b))/2),
                     __e));

/* Problem 47 (line 2004) */
between2unitpulse(__e):=block([opsubst:true],
                  subst('between = lambda([__x,__a,__b,[__o]],
                                          block([_n1,_n2],
                                                if member('lclosed,__o)
                                                    then (_n1:1/2,_n2:(-1)/2)
                                                    elseif member('open,__o)
                                                    then (_n1:(-1)/2,
                                                          _n2:(-1)/2)
                                                    elseif member(
                                                    'rclosed,__o)
                                                    then (_n1:(-1)/2,_n2:1/2)
                                                    elseif member('closed,__o)
                                                    then (_n1:1/2,_n2:1/2)
                                                    else (_n1:0,_n2:0),
                                                ((1+signum(__b-__a))
                                                 *(unit_pulse(
                                                  __x/(__b-__a)+__a/(__a-__b))
                                                  +_n1*unit_spike(__x-__a)
                                                  +_n2*unit_spike(__x-__b)))
                                                 /2)),__e));
/* Erroneous Result?:
between2unitpulse(__e):=block([opsubst:true],
                  subst('between = lambda([__x,__a,__b,[__o]],
                                          block([_n1,_n2],
                                                if member('lclosed,__o)
                                                    then (_n1:1/2,_n2:(-1)/2)
                                                    elseif member('open,__o)
                                                    then (_n1:(-1)/2,
                                                          _n2:(-1)/2)
                                                    elseif member(
                                                    'rclosed,__o)
                                                    then (_n1:(-1)/2,_n2:1/2)
                                                    elseif member('closed,__o)
                                                    then (_n1:1/2,_n2:1/2)
                                                    else (_n1:0,_n2:0),
                                                ((1+signum(__b-__a))
                                                 *(unit_pulse(
                                                  __x/(__b-__a)+__a/(__a-__b))
                                                  +_n1*unit_spike(__x-__a)
                                                  +_n2*unit_spike(__x-__b)))
                                                 /2)),__e)) */ 
/* Expected result: */
simppwdeltas(__e):=block([inflag:true,_l,_m,_q,_p,lk,_sum:0,_ans],
             __e:expandwrt(__e,'pwdelta),
             if safe_op(__e) = "+"
                 then (for _p in __e do _sum:_sum+simppwdeltas(_p),_sum)
                 else (_m:gatherargs(__e,"^"),
                       _l1:flatten(gatherargs(__e,'pwdelta)),
                       for lk in _l1 do
                           (__e:ratsubst(0,lk*pwdelta(lk),__e),
                            __e:ratsubst(0,signum(lk)*pwdelta(lk),__e),
                            __e:ratsubst(0,sin(lk)*pwdelta(lk),__e),
                            __e:ratsubst(0,tan(lk)*pwdelta(lk),__e),
                            while not emptyp(_m) do
                                  (_p:first(_m),_m:rest(_m),_q:second(_p),
                                   if _q > 0
                                       then (
                                       __e:ratsubst(0,lk^_q*pwdelta(lk),__e),
                                       __e
                                        :ratsubst(0,sin(lk)^_q*pwdelta(lk),
                                                  __e),
                                       __e
                                        :ratsubst(0,sin(lk^_q)*pwdelta(lk),
                                                  __e),
                                       __e
                                        :ratsubst(0,tan(lk)^_q*pwdelta(lk),
                                                  __e),
                                       __e
                                        :ratsubst(0,tan(lk^_q)*pwdelta(lk),
                                                  __e)))),__e));

/* Problem 48 (line 2131) */
simpspikes(__e):=block(
           [inflag:true,use_between:false,_l,_m,_q,_p,lk,_sum:0,_done:false,
            _most1,_most2,_tmp,_tmp1,_stop,_ans],
           __e:expandwrt(__e,'unit_spike),
           if safe_op(__e) = "+"
               then (for _p in __e do _sum:_sum+simpspikes(_p),_sum)
               else (_m:gatherargs(__e,"^"),
                     for lk in _m do
                         if nonnegintegerp(second(lk))
                              and safe_op(first(lk)) = 'unit_spike
                             then __e:ratsubst(first(lk),first(lk)^second(lk),
                                               __e),
                     _l:listify(setify(flatten(gatherargs(__e,'unit_spike)))),
                     for lk in _l do
                         (__e:subst(0,lk*unit_spike(lk),__e),
                          __e:subst(0,signum(lk)*unit_spike(lk),__e),
                          __e:subst(0,sin(lk)*unit_spike(lk),__e),
                          __e:subst(0,tan(lk)*unit_spike(lk),__e)),
                     _l:listify(setify(flatten(gatherargs(__e,'unit_spike)))),
                     while not emptyp(_l) do
                           (_p:first(_l),_l:rest(_l),
                            _l2:listify(
                                setify(flatten(gatherargs(__e,'unit_spike)))),
                            while not emptyp(_l2) do
                                  (_q:first(_l2),_l2:rest(_l2),
                                   if is(notequal(_p,_q)) = true
                                       then __e
                                       :ratsubst(0,
                                                 unit_spike(_p)
                                                  *unit_spike(_q),__e))),
                     _l:flatten(gatherargs(__e,'unit_spike)),
                     if not emptyp(_l)
                         then (_tmp:__e,
                               while not emptyp(_l) do
                                     (_p:first(_l),_l:rest(_l),
                                      _tmp:subst(1,unit_spike(_p),_tmp)),
                               _most1:reverse(countvars(_tmp)),
                               _l:flatten(gatherargs(__e,'unit_spike)),
                               _most2:reverse(countvars(_l)),_stop:false,
                               if not emptyp(_most1) and not emptyp(_most2)
                                                     and is(
                                                     equal(
                                                      first(first(_most1)),
                                                      first(first(_most2))))
                                   then _x:first(first(_most1))
                                   elseif emptyp(_most1) and emptyp(_most2)
                                   then _stop:true
                                   else _x:first(first(_most2)),
                               if not _stop
                                   then (_expr:first(_l),
                                         if listp(_ans:linearfunc(_expr,_x))
                                             then (if 
                                             is(notequal(first(_ans),0))
                                               = true
                                              then (
                                              _ans
                                               :(-second(_ans))/first(_ans),
                                              _tmp
                                               :subst(1,unit_spike(_expr),
                                                      __e),
                                              _t
                                               :errcatch(
                                                _tmp1
                                                 :sublis([_x = _ans],
                                                         ratsimp(_tmp))),
                                              if _t = [] then __e
                                                  else __e
                                                  :_tmp1
                                                   *unit_spike(_expr))))),
                     __e)),use_between = false;
/* Erroneous Result?:
simpspikes(__e):=block(
           [inflag:true,use_between:false,_l,_m,_q,_p,lk,_sum:0,_done:false,
            _most1,_most2,_tmp,_tmp1,_stop,_ans],
           __e:expandwrt(__e,'unit_spike),
           if safe_op(__e) = "+"
               then (for _p in __e do _sum:_sum+simpspikes(_p),_sum)
               else (_m:gatherargs(__e,"^"),
                     for lk in _m do
                         if nonnegintegerp(second(lk))
                              and safe_op(first(lk)) = 'unit_spike
                             then __e:ratsubst(first(lk),first(lk)^second(lk),
                                               __e),
                     _l:listify(setify(flatten(gatherargs(__e,'unit_spike)))),
                     for lk in _l do
                         (__e:subst(0,lk*unit_spike(lk),__e),
                          __e:subst(0,signum(lk)*unit_spike(lk),__e),
                          __e:subst(0,sin(lk)*unit_spike(lk),__e),
                          __e:subst(0,tan(lk)*unit_spike(lk),__e)),
                     _l:listify(setify(flatten(gatherargs(__e,'unit_spike)))),
                     while not emptyp(_l) do
                           (_p:first(_l),_l:rest(_l),
                            _l2:listify(
                                setify(flatten(gatherargs(__e,'unit_spike)))),
                            while not emptyp(_l2) do
                                  (_q:first(_l2),_l2:rest(_l2),
                                   if is(notequal(_p,_q)) = true
                                       then __e
                                       :ratsubst(0,
                                                 unit_spike(_p)
                                                  *unit_spike(_q),__e))),
                     _l:flatten(gatherargs(__e,'unit_spike)),
                     if not emptyp(_l)
                         then (_tmp:__e,
                               while not emptyp(_l) do
                                     (_p:first(_l),_l:rest(_l),
                                      _tmp:subst(1,unit_spike(_p),_tmp)),
                               _most1:reverse(countvars(_tmp)),
                               _l:flatten(gatherargs(__e,'unit_spike)),
                               _most2:reverse(countvars(_l)),_stop:false,
                               if not emptyp(_most1) and not emptyp(_most2)
                                                     and is(
                                                     equal(
                                                      first(first(_most1)),
                                                      first(first(_most2))))
                                   then _x:first(first(_most1))
                                   elseif emptyp(_most1) and emptyp(_most2)
                                   then _stop:true
                                   else _x:first(first(_most2)),
                               if not _stop
                                   then (_expr:first(_l),
                                         if listp(_ans:linearfunc(_expr,_x))
                                             then (if 
                                             is(notequal(first(_ans),0))
                                               = true
                                              then (
                                              _ans
                                               :(-second(_ans))/first(_ans),
                                              _tmp
                                               :subst(1,unit_spike(_expr),
                                                      __e),
                                              _t
                                               :errcatch(
                                                _tmp1
                                                 :sublis([_x = _ans],
                                                         ratsimp(_tmp))),
                                              if _t = [] then __e
                                                  else __e
                                                  :_tmp1
                                                   *unit_spike(_expr))))),
                     __e)) */ 
/* Expected result: */
if2sum(__e):=block([opsubst:true,inflag:true],
       subst('%if = lambda([__s,__a,__b],
                           block([_p:safe_op(__s),_q:safe_op(inpart(__s,1)),
                                  _r:safe_op(inpart(__s,2)),
                                  _a:rhs(inpart(__s,1)),_b:rhs(inpart(__s,2)),
                                  _x:lhs(inpart(__s,1)),
                                  _x1:lhs(inpart(__s,1)),
                                  _x2:lhs(inpart(__s,2))],
                                 if safe_op(__s) = ">"
                                     then ((signum(lhs(__s))
                                     +1-unit_spike(lhs(__s)))
                                     /2)
                                     *__a
                                     +((1-signum(lhs(__s))
                                         +unit_spike(lhs(__s)))
                                      /2)
                                      *__b elseif safe_op(__s) = "="
                                     then unit_spike(lhs(__s))*__a
                                     +(1-unit_spike(lhs(__s)))*__b
                                     elseif safe_op(__s) = "#"
                                     then unit_spike(lhs(__s))*__b
                                     +(1-unit_spike(lhs(__s)))*__a
                                     elseif apply(_p,[true,false,false])
                                      = true
                                      and apply(_p,[false,false,false])
                                       = false and _q = "=" and _r = ">"
                                      and _x1 = _x2
                                     then (__a*(signum(_x)+unit_spike(_x)+1))
                                     /2
                                     +(__b*(1-signum(_x)-unit_spike(_x)))/2
                                     elseif apply(_p,[true,false,false])
                                      = true
                                      and apply(_p,[false,false,false])
                                       = false and _q = ">" and _r = "="
                                      and _x1 = _x2
                                     then ((signum(_x)+unit_spike(_x)+1)/2)
                                     *__a
                                     +((1-signum(_x)-unit_spike(_x))/2)*__b
                                     elseif apply(_p,[true,true,true]) = true
                                      and _x1 = _x2
                                      and apply(_p,[false,true,true]) = false
                                      and _q = ">" and _r = "<"
                                     then __a*between(_x,_a,_b,'open)
                                     +__b*(1-between(_x,_a,_b,'open))
                                     else %if(__s,__a,__b))),__e));

/* Problem 49 (line 2175) */
pushoutiif(__e):=sum2iif(iif2sum(__e));
/* Erroneous Result?:
pushoutiif(__e):=sum2iif(iif2sum(__e)) */ 
/* Expected result: */
iif2sum(__e):=block([opsubst:true,inflag:true,__s,__a,__b],
        subst('iif = lambda([__s,__a,__b],
                            block([_op,_p,_q,_r,_a,_b,_x,_x1,_x2],
                                  _op:safe_op(__s),_p:lhs(__s),_q:rhs(__s),
                                  _p:_p-_q,
                                  if _op = ">" then __s:_p > 0
                                      elseif _op = "<" then __s:_p < 0
                                      elseif _op = ">=" then __s:_p >= 0
                                      elseif _op = "<=" then __s:_p <= 0,
                                  _p:safe_op(__s),_q:safe_op(inpart(__s,1)),
                                  _r:safe_op(inpart(__s,2)),
                                  _a:rhs(inpart(__s,1)),_b:rhs(inpart(__s,2)),
                                  _x:lhs(inpart(__s,1)),
                                  _x1:lhs(inpart(__s,1)),
                                  _x2:lhs(inpart(__s,2)),
                                  if safe_op(__s) = ">"
                                      then ((signum(lhs(__s))
                                      +1-unit_spike(lhs(__s)))
                                      /2)
                                      *__a
                                      +((1-signum(lhs(__s))
                                          +unit_spike(lhs(__s)))
                                       /2)
                                       *__b elseif safe_op(__s) = "<"
                                      then ((1-signum(lhs(__s))
                                              -unit_spike(lhs(__s)))
                                      /2)
                                      *__a
                                      +((signum(lhs(__s))+unit_spike(lhs(__s))
                                                         +1)
                                       /2)
                                       *__b elseif safe_op(__s) = ">="
                                      then ((signum(lhs(__s))
                                      +1+unit_spike(lhs(__s)))
                                      /2)
                                      *__a
                                      +((1-signum(lhs(__s))
                                          -unit_spike(lhs(__s)))
                                       /2)
                                       *__b elseif safe_op(__s) = "<="
                                      then ((1-signum(lhs(__s))
                                              +unit_spike(lhs(__s)))
                                      /2)
                                      *__a
                                      +((signum(lhs(__s))-unit_spike(lhs(__s))
                                                         +1)
                                       /2)
                                       *__b elseif safe_op(__s) = 'equal
                                      then unit_spike(
                                      first(args(__s))-second(args(__s)))
                                      *__a
                                      +(1
                                       -unit_spike(
                                        first(args(__s))-second(args(__s))))
                                       *__b elseif safe_op(__s) = 'notequal
                                      then unit_spike(
                                      first(args(__s))-second(args(__s)))
                                      *__b
                                      +(1
                                       -unit_spike(
                                        first(args(__s))-second(args(__s))))
                                       *__a else iif(__s,__a,__b))),__e));

/* Problem 50 (line 2222) */
sum2iif(__e):=signum2iif(unitspike2iif(between2iif(unitpulse2between(__e))));
/* Erroneous Result?:
sum2iif(__e):=signum2iif(unitspike2iif(between2iif(unitpulse2between(__e)))) */ 
/* Expected result: */
pullinif(__e):=block([_done:false,_a,inflag:true],
         while not _done do
               (_a:_pull_in_if(__e),if _a = __e then _done:'true,__e:_a),_a);

/* Problem 51 (line 2278) */
_pull_in_if(__e):=block(
            [opsubst:'true,inflag:'true,%a,%__b,_a,_b,_sum:0,_pod:1,_exp,_op,
             _args,_p],
            if mapatom(__e) then __e
                elseif safe_op(__e) = "+" and not freeof('%if,args(__e))
                then (for _p in __e do _sum:add_it_if(_sum,_pull_in_if(_p)),
                      _sum)
                elseif safe_op(__e) = "*" and not freeof('%if,args(__e))
                then (for _p in __e do _pod:mult_it_if(_pod,_pull_in_if(_p)),
                      _pod)
                elseif safe_op(__e) = "^" and not freeof('%if,args(__e))
                then _pull_in_if(exp_it_if(_pull_in_if(first(__e)),
                                           _pull_in_if(second(__e))))
                elseif length(args(__e)) = 1 and not freeof('%if,args(__e))
                then (_op:safe_op(__e),%a:_pull_in_if(first(args(__e))),
                      if safe_op(%a) = '%if
                          then apply('%if,
                                     [inpart(%a,1),
                                      _pull_in_if(
                                       _op(_pull_in_if(inpart(%a,2)))),
                                      _pull_in_if(
                                       _op(_pull_in_if(inpart(%a,3))))])
                          else _pull_in_if(_op(_pull_in_if(%a))))
                elseif safe_op(__e) = '%if and not freeof('%if,args(__e))
                then (%a:args(__e),
                      apply('%if,
                            [inpart(%a,1),_pull_in_if(inpart(%a,2)),
                             _pull_in_if(inpart(%a,3))]))
                elseif freeof('%if,args(__e)) then __e else __e);
/* Erroneous Result?:
_pull_in_if(__e):=block(
            [opsubst:'true,inflag:'true,%a,%__b,_a,_b,_sum:0,_pod:1,_exp,_op,
             _args,_p],
            if mapatom(__e) then __e
                elseif safe_op(__e) = "+" and not freeof('%if,args(__e))
                then (for _p in __e do _sum:add_it_if(_sum,_pull_in_if(_p)),
                      _sum)
                elseif safe_op(__e) = "*" and not freeof('%if,args(__e))
                then (for _p in __e do _pod:mult_it_if(_pod,_pull_in_if(_p)),
                      _pod)
                elseif safe_op(__e) = "^" and not freeof('%if,args(__e))
                then _pull_in_if(exp_it_if(_pull_in_if(first(__e)),
                                           _pull_in_if(second(__e))))
                elseif length(args(__e)) = 1 and not freeof('%if,args(__e))
                then (_op:safe_op(__e),%a:_pull_in_if(first(args(__e))),
                      if safe_op(%a) = '%if
                          then apply('%if,
                                     [inpart(%a,1),
                                      _pull_in_if(
                                       _op(_pull_in_if(inpart(%a,2)))),
                                      _pull_in_if(
                                       _op(_pull_in_if(inpart(%a,3))))])
                          else _pull_in_if(_op(_pull_in_if(%a))))
                elseif safe_op(__e) = '%if and not freeof('%if,args(__e))
                then (%a:args(__e),
                      apply('%if,
                            [inpart(%a,1),_pull_in_if(inpart(%a,2)),
                             _pull_in_if(inpart(%a,3))]))
                elseif freeof('%if,args(__e)) then __e else __e) */ 
/* Expected result: */
add_it_if(%a,%b):=block([inflag:true],
          if not mapatom(%b) and op(%b) = '%if
              then %if(inpart(%b,1),_pull_in_if(%a+inpart(%b,2)),
                       _pull_in_if(%a+inpart(%b,3)))
              else (if not mapatom(%a) and op(%a) = '%if
                        then %if(inpart(%a,1),_pull_in_if(%b+inpart(%a,2)),
                                 _pull_in_if(%b+inpart(%a,3))) else %a+%b));

/* Problem 52 (line 2310) */
mult_it_if(%a,%b):=block([inflag:true],
           if not mapatom(%b) and op(%b) = '%if
               then %if(inpart(%b,1),_pull_in_if(%a*inpart(%b,2)),
                        _pull_in_if(%a*inpart(%b,3)))
               else (if not mapatom(%a) and op(%a) = '%if
                         then %if(inpart(%a,1),_pull_in_if(%b*inpart(%a,2)),
                                  _pull_in_if(%b*inpart(%a,3))) else %a*%b));
/* Erroneous Result?:
mult_it_if(%a,%b):=block([inflag:true],
           if not mapatom(%b) and op(%b) = '%if
               then %if(inpart(%b,1),_pull_in_if(%a*inpart(%b,2)),
                        _pull_in_if(%a*inpart(%b,3)))
               else (if not mapatom(%a) and op(%a) = '%if
                         then %if(inpart(%a,1),_pull_in_if(%b*inpart(%a,2)),
                                  _pull_in_if(%b*inpart(%a,3))) else %a*%b)) */ 
/* Expected result: */
exp_it_if(%a,%b):=block([inflag:true],
          if not mapatom(%b) and op(%b) = '%if
              then %if(inpart(%b,1),_pull_in_if(%a^inpart(%b,2)),
                       _pull_in_if(%a^inpart(%b,3)))
              else (if not mapatom(%a) and op(%a) = '%if
                        then %if(inpart(%a,1),_pull_in_if(inpart(%a,2)^%b),
                                 _pull_in_if(inpart(%a,3)^%b)) else %a^%b));

/* Problem 53 (line 2338) */
pulliniif(__e):=block([_done:false,_a,inflag:true],
          while not _done do
                (_a:_pull_in_iif(__e),if _a = __e then _done:'true,__e:_a),_a);
/* Erroneous Result?:
pulliniif(__e):=block([_done:false,_a,inflag:true],
          while not _done do
                (_a:_pull_in_iif(__e),if _a = __e then _done:'true,__e:_a),_a) */ 
/* Expected result: */
_pull_in_iif(__e):=block(
             [opsubst:'true,inflag:'true,%a,%b,_a,_b,_sum:0,_pod:1,_exp,_op,
              _args,_p],
             if mapatom(__e) then __e
                 elseif safe_op(__e) = "+" and not freeof('iif,args(__e))
                 then (for _p in __e do
                           _sum:add_it_iif(_sum,_pull_in_iif(_p)),_sum)
                 elseif safe_op(__e) = "*" and not freeof('iif,args(__e))
                 then (for _p in __e do
                           _pod:mult_it_iif(_pod,_pull_in_iif(_p)),_pod)
                 elseif safe_op(__e) = "^" and not freeof('iif,args(__e))
                 then _pull_in_iif(exp_it_iif(_pull_in_iif(first(__e)),
                                              _pull_in_iif(second(__e))))
                 elseif length(args(__e)) = 1 and not freeof('iif,args(__e))
                 then (_op:safe_op(__e),%a:_pull_in_iif(first(args(__e))),
                       if safe_op(%a) = 'iif
                           then apply('iif,
                                      [inpart(%a,1),
                                       _pull_in_iif(
                                        _op(_pull_in_iif(inpart(%a,2)))),
                                       _pull_in_iif(
                                        _op(_pull_in_iif(inpart(%a,3))))])
                           else _pull_in_iif(_op(_pull_in_iif(%a))))
                 elseif safe_op(__e) = 'iif and not freeof('iif,args(__e))
                 then (%a:args(__e),
                       apply('iif,
                             [inpart(%a,1),_pull_in_iif(inpart(%a,2)),
                              _pull_in_iif(inpart(%a,3))]))
                 elseif freeof('iif,args(__e)) then __e else __e);

/* Problem 54 (line 2395) */
add_it_iif(%a,%b):=block([inflag:true],
           if not mapatom(%b) and op(%b) = 'iif
               then iif(inpart(%b,1),_pull_in_iif(%a+inpart(%b,2)),
                        _pull_in_iif(%a+inpart(%b,3)))
               else (if not mapatom(%a) and op(%a) = 'iif
                         then iif(inpart(%a,1),_pull_in_iif(%b+inpart(%a,2)),
                                  _pull_in_iif(%b+inpart(%a,3))) else %a+%b));
/* Erroneous Result?:
add_it_iif(%a,%b):=block([inflag:true],
           if not mapatom(%b) and op(%b) = 'iif
               then iif(inpart(%b,1),_pull_in_iif(%a+inpart(%b,2)),
                        _pull_in_iif(%a+inpart(%b,3)))
               else (if not mapatom(%a) and op(%a) = 'iif
                         then iif(inpart(%a,1),_pull_in_iif(%b+inpart(%a,2)),
                                  _pull_in_iif(%b+inpart(%a,3))) else %a+%b)) */ 
/* Expected result: */
mult_it_iif(%a,%b):=block([inflag:true],
            if not mapatom(%b) and op(%b) = 'iif
                then iif(inpart(%b,1),_pull_in_iif(%a*inpart(%b,2)),
                         _pull_in_iif(%a*inpart(%b,3)))
                else (if not mapatom(%a) and op(%a) = 'iif
                          then iif(inpart(%a,1),_pull_in_iif(%b*inpart(%a,2)),
                                   _pull_in_iif(%b*inpart(%a,3))) else %a*%b));

/* Problem 55 (line 2427) */
exp_it_iif(%a,%b):=block([inflag:true],
           if not mapatom(%b) and op(%b) = 'iif
               then iif(inpart(%b,1),_pull_in_iif(%a^inpart(%b,2)),
                        _pull_in_iif(%a^inpart(%b,3)))
               else (if not mapatom(%a) and op(%a) = 'iif
                         then iif(inpart(%a,1),_pull_in_iif(inpart(%a,2)^%b),
                                  _pull_in_iif(inpart(%a,3)^%b)) else %a^%b));
/* Erroneous Result?:
exp_it_iif(%a,%b):=block([inflag:true],
           if not mapatom(%b) and op(%b) = 'iif
               then iif(inpart(%b,1),_pull_in_iif(%a^inpart(%b,2)),
                        _pull_in_iif(%a^inpart(%b,3)))
               else (if not mapatom(%a) and op(%a) = 'iif
                         then iif(inpart(%a,1),_pull_in_iif(inpart(%a,2)^%b),
                                  _pull_in_iif(inpart(%a,3)^%b)) else %a^%b)) */ 
/* Expected result: */
if2iif(__e):=block([opsubst:true,inflag:true],
       subst('%if = lambda([__s,__a,__b],
                           block([_p:safe_op(__s),_q:safe_op(inpart(__s,1)),
                                  _r:safe_op(inpart(__s,2)),
                                  _a:rhs(inpart(__s,1)),_b:rhs(inpart(__s,2)),
                                  _x:lhs(inpart(__s,1)),
                                  _x1:lhs(inpart(__s,1)),
                                  _x2:lhs(inpart(__s,2))],
                                 if member(safe_op(__s),
                                           [">",">=","<","<=",'equal,
                                            'notequal])
                                     then simp_iif(iif(__s,__a,__b))
                                     elseif apply(_p,[true,false,false])
                                      = true
                                      and apply(_p,[false,false,false])
                                       = false and _q = "=" and _r = ">"
                                      and _x2 = _x1 and length(args(__s)) = 2
                                     then simp_iif(iif(_x >= _a,__a,__b))
                                     elseif apply(_p,[true,false,false])
                                      = true
                                      and apply(_p,[false,false,false])
                                       = false and _q = ">" and _r = "="
                                      and _x1 = _x2 and length(args(__s)) = 2
                                     then simp_iif(iif(_x >= _a,__a,__b))
                                     elseif apply(_p,[true,true,true]) = true
                                      and apply(_p,[false,true,true]) = false
                                      and member(_q,[">",">=","<","<="])
                                      and member(_r,[">",">=","<","<="])
                                      and _x1 = _x2 and length(args(__s)) = 2
                                     then simp_iif(
                                     iif(apply(_q,[_x,_a]),
                                         iif(apply(_r,[_x,_b]),__a,__b),__b))
                                     else %if(__s,__a,__b))),__e));

/* Problem 56 (line 2472) */
signum2abs2(__e):=block([__l],__e:simpsignum(__e),
            __l:flatten(gatherargs(__e,'signum)),
            for lk in __l do __e:ratsubst(abs(lk),lk*signum(lk),__e),__e);
/* Erroneous Result?:
signum2abs2(__e):=block([__l],__e:simpsignum(__e),
            __l:flatten(gatherargs(__e,'signum)),
            for lk in __l do __e:ratsubst(abs(lk),lk*signum(lk),__e),__e) */ 
/* Expected result: */
between2if(__e):=block([opsubst:true,inflag:true],
           subst('between = lambda([__x,__a,__b,__o],[_a],
                                   if __o = 'lclosed
                                       then %if(__x >= __a and __x < __b,1,0)
                                       elseif __o = 'closed
                                       then %if(__x >= __a and __x <= __b,1,0)
                                       elseif __o = 'rclosed
                                       then %if(__x > __a and __x <= __b,1,0)
                                       elseif __o = 'open
                                       then %if(__x > __a and __x < __b,1,0)
                                       elseif __o = 'halfopen
                                       then %if(__x > __a,
                                                %if(__x < __b,1,
                                                    %if(__x = __b,1/2,0)),
                                                %if(__x = __a,
                                                    %if(__b > __a,1/2,0),0))
                                       else %if(__x > __a,
                                                %if(__x < __b,1,
                                                    %if(__x = __b,1/2,0)),
                                                %if(__x = __a,
                                                    %if(__b > __a,1/2,0),0))),
                 __e));

/* Problem 57 (line 2516) */
between2iif(__e):=block([opsubst:true,inflag:true],
            subst('between = lambda([__x,__a,__b,__o],[_a],
                                    if __o = 'lclosed
                                        then iif(__x >= __a,
                                                 iif(__x < __b,1,0),0)
                                        elseif __o = 'closed
                                        then iif(__x >= __a,
                                                 iif(__x <= __b,1,0),0)
                                        elseif __o = 'rclosed
                                        then iif(__x > __a,
                                                 iif(__x <= __b,1,0),0)
                                        elseif __o = 'open
                                        then iif(__x > __a,iif(__x < __b,1,0),
                                                 0) elseif __o = 'halfopen
                                        then iif(__x > __a,
                                                 iif(__x < __b,1,
                                                     iif(equal(__x,__b),1/2,
                                                         0)),
                                                 iif(equal(__x,__a),
                                                     iif(__b > __a,1/2,0),0))
                                        else iif(__x > __a,
                                                 iif(__x < __b,1,
                                                     iif(equal(__x,__b),1/2,
                                                         0)),
                                                 iif(equal(__x,__a),
                                                     iif(__b > __a,1/2,0),
                                                     0))),__e));
/* Erroneous Result?:
between2iif(__e):=block([opsubst:true,inflag:true],
            subst('between = lambda([__x,__a,__b,__o],[_a],
                                    if __o = 'lclosed
                                        then iif(__x >= __a,
                                                 iif(__x < __b,1,0),0)
                                        elseif __o = 'closed
                                        then iif(__x >= __a,
                                                 iif(__x <= __b,1,0),0)
                                        elseif __o = 'rclosed
                                        then iif(__x > __a,
                                                 iif(__x <= __b,1,0),0)
                                        elseif __o = 'open
                                        then iif(__x > __a,iif(__x < __b,1,0),
                                                 0) elseif __o = 'halfopen
                                        then iif(__x > __a,
                                                 iif(__x < __b,1,
                                                     iif(equal(__x,__b),1/2,
                                                         0)),
                                                 iif(equal(__x,__a),
                                                     iif(__b > __a,1/2,0),0))
                                        else iif(__x > __a,
                                                 iif(__x < __b,1,
                                                     iif(equal(__x,__b),1/2,
                                                         0)),
                                                 iif(equal(__x,__a),
                                                     iif(__b > __a,1/2,0),
                                                     0))),__e)) */ 
/* Expected result: */
unitpulse2between(__e):=block([opsubst:true],
                  subst('unit_pulse = lambda([_s],between(_s,0,1)),__e));

/* Problem 58 (line 2519) */
if2ifthen(__e):=block([opsubst:true],
          subst('%if = lambda([_cnd,__a,__b],if _cnd then __a else __b),__e));
/* Erroneous Result?:
if2ifthen(__e):=block([opsubst:true],
          subst('%if = lambda([_cnd,__a,__b],if _cnd then __a else __b),__e)) */ 
/* Expected result: */
iif2ifthen(__e):=block([opsubst:true],
           subst('iif = lambda([_cnd,__a,__b],if _cnd then __a else __b),__e));

/* Problem 59 (line 2521) */
unitspike2if(__e):=block([opsubst:true],
             subst('unit_spike = lambda([__s],%if(equal(__s,0),1,0)),__e));
/* Erroneous Result?:
unitspike2if(__e):=block([opsubst:true],
             subst('unit_spike = lambda([__s],%if(equal(__s,0),1,0)),__e)) */ 
/* Expected result: */
unitspike2iif(__e):=block([opsubst:true],
              subst('unit_spike = lambda([__s],iif(equal(__s,0),1,0)),__e));

/* Problem 60 (line 2523) */
signum2if(__e):=block([opsubst:true,inflag:true],
          subst('signum = lambda([__s],%if(__s > 0,1,%if(__s < 0,-1,0))),__e));
/* Erroneous Result?:
signum2if(__e):=block([opsubst:true,inflag:true],
          subst('signum = lambda([__s],%if(__s > 0,1,%if(__s < 0,-1,0))),__e)) */ 
/* Expected result: */
signum2iif(__e):=block([opsubst:true,inflag:true],
           subst('signum = lambda([__s],iif(__s > 0,1,iif(__s < 0,-1,0))),
                 __e));

/* Problem 61 (line 2525) */
abs2iif(__e):=block([opsubst:true,inflag:true],
        subst('abs = lambda([__s],%if(__s > 0,__s,-__s)),__e));
/* Erroneous Result?:
abs2iif(__e):=block([opsubst:true,inflag:true],
        subst('abs = lambda([__s],%if(__s > 0,__s,-__s)),__e)) */ 
/* Expected result: */
abs2iif(__e):=block([opsubst:true,inflag:true],
        subst('abs = lambda([__s],iif(__s > 0,__s,-__s)),__e));

/* Problem 62 (line 2527) */
unitstep2if(__e):=block([opsubst:true],
            subst('unit_step = lambda([__s],%if(__s > 0,1,0)),__e));
/* Erroneous Result?:
unitstep2if(__e):=block([opsubst:true],
            subst('unit_step = lambda([__s],%if(__s > 0,1,0)),__e)) */ 
/* Expected result: */
unitstep2iif(__e):=block([opsubst:true],
             subst('unit_step = lambda([__s],iif(__s > 0,1,0)),__e));

/* Problem 63 (line 2529) */
charfun2between(_e):=block([opsubst:true],
                subst('charfun2 = lambda([__x,__a,__b],
                                         between(__x,__a,__b,'lclosed)),_e));
/* Erroneous Result?:
charfun2between(_e):=block([opsubst:true],
                subst('charfun2 = lambda([__x,__a,__b],
                                         between(__x,__a,__b,'lclosed)),_e)) */ 
/* Expected result: */
charfun2sum(_e):=block([opsubst:true],
            subst('charfun2 = lambda([__x,__a,__b],
                                     iif2sum(
                                      between2iif(
                                       between(__x,__a,__b,'lclosed)))),_e));

/* Problem 64 (line 2531) */
unitspike2unitstep(__e):=block([opsubst:true],
                   subst('unit_spike = lambda([__s],
                                              (-unit_step(__s))
                                               +2*unit_step(-__s)
                                                 *unit_step(__s)
                                               -unit_step(-__s)+1),__e));
/* Erroneous Result?:
unitspike2unitstep(__e):=block([opsubst:true],
                   subst('unit_spike = lambda([__s],
                                              (-unit_step(__s))
                                               +2*unit_step(-__s)
                                                 *unit_step(__s)
                                               -unit_step(-__s)+1),__e)) */ 
/* Expected result: */
unitpulse2unitstep(__e):=block([opsubst:true],
                   subst('unit_pulse = lambda([__s],
                                              (unit_step(__s)-unit_step(-__s)
                                                             -unit_step(__s-1)
                                                             +unit_step(
                                                              1-__s))
                                               /2),__e));

/* Problem 65 (line 2533) */
abs2unitstep(__e):=block([opsubst:true],
             subst('abs = lambda([__s],
                                 __s*unit_step(__s)-__s*unit_step(-__s)),__e));
/* Erroneous Result?:
abs2unitstep(__e):=block([opsubst:true],
             subst('abs = lambda([__s],
                                 __s*unit_step(__s)-__s*unit_step(-__s)),__e)) */ 
/* Expected result: */
signum2unitstep(__e):=block([opsubst:true],
                subst('signum = lambda([__s],unit_step(__s)-unit_step(-__s)),
                      __e));

/* Problem 66 (line 2535) */
unitpulse2signum(__e):=block([opsubst:true],
                 subst('unit_pulse = lambda([__s],
                                            (signum(__s)-signum(__s-1))/2),
                       __e));
/* Erroneous Result?:
unitpulse2signum(__e):=block([opsubst:true],
                 subst('unit_pulse = lambda([__s],
                                            (signum(__s)-signum(__s-1))/2),
                       __e)) */ 
/* Expected result: */
abs2signum(__e):=block([opsubst:true],
           subst('abs = lambda([__s],__s*signum(__s)),__e));

/* Problem 67 (line 2537) */
unitspike2signum(__e):=block([opsubst:true],
                 subst('unit_spike = lambda([__s],1-signum(__s)^2),__e));
/* Erroneous Result?:
unitspike2signum(__e):=block([opsubst:true],
                 subst('unit_spike = lambda([__s],1-signum(__s)^2),__e)) */ 
/* Expected result: */
unitstep2signum(__e):=block([opsubst:true],
                subst('unit_step = lambda([__s],
                                          (signum(__s)+1-unit_spike(__s))/2),
                      __e));

/* Problem 68 (line 2539) */
unitspike2signum(__e):=block([opsubst:true],
                 subst('unit_spike = lambda([__s],1-signum(__s)^2),__e));
/* Erroneous Result?:
unitspike2signum(__e):=block([opsubst:true],
                 subst('unit_spike = lambda([__s],1-signum(__s)^2),__e)) */ 
/* Expected result: */
iif2if(__e):=block([opsubst:true],
       subst('iif = lambda([_cnd,__a,__b],%if(_cnd,__a,__b)),__e));

/* Problem 69 (line 2541) */
if2iif(__e):=block([opsubst:true],
       subst('%if = lambda([_cnd,__a,__b],iif(_cnd,__a,__b)),__e));
/* Erroneous Result?:
if2iif(__e):=block([opsubst:true],
       subst('%if = lambda([_cnd,__a,__b],iif(_cnd,__a,__b)),__e)) */ 
/* Expected result: */
hstep2signum(__e):=block([opsubst:true],
             subst('hstep = lambda([_s],(1+signum(_s))/2),__e));

/* Problem 70 (line 2543) */
signum2hstep(__e):=block([opsubst:true],
             subst('signum = lambda([_s],2*hstep(_s)-1),__e));
/* Erroneous Result?:
signum2hstep(__e):=block([opsubst:true],
             subst('signum = lambda([_s],2*hstep(_s)-1),__e)) */ 
/* Expected result: */
ifthen2if(__e):=block([opsubst:true],
          subst("if" = lambda([[_v]],restofif(_v)),__e));

/* Problem 71 (line 2560) */
restofif(__l):=block([_retval:0],
         if length(__l) # 0 and __l[1] # true
             then %if(__l[1],__l[2],restofif(rest(__l,2)))
             elseif __l[1] = true then __l[2]);
/* Erroneous Result?:
restofif(__l):=block([_retval:0],
         if length(__l) # 0 and __l[1] # true
             then %if(__l[1],__l[2],restofif(rest(__l,2)))
             elseif __l[1] = true then __l[2]) */ 
/* Expected result: */
ifthen2iif(__e):=block([opsubst:true],
           subst("if" = lambda([[_v]],restofiif(_v)),__e));

/* Problem 72 (line 2577) */
restofiif(__l):=block([_retval:0],
          if length(__l) # 0 and __l[1] # true
              then iif(__l[1],__l[2],restofiif(rest(__l,2)))
              elseif __l[1] = true then __l[2]);
/* Erroneous Result?:
restofiif(__l):=block([_retval:0],
          if length(__l) # 0 and __l[1] # true
              then iif(__l[1],__l[2],restofiif(rest(__l,2)))
              elseif __l[1] = true then __l[2]) */ 
/* Expected result: */
bffind_root(__expr,__f,__x,__low,__high,__digits):=block(
            [fpprec:fpprec+__digits+20,_side,_fb,_ft,_fn,_b,_t,_n,
             _retval:'unknown,_theaccuracy:10^-__digits],_b:bfloat(__low),
            _t:bfloat(__high),_fb:at(__expr,__x = _b),_ft:at(__expr,__x = _t),
            _fb:apply('ev,flatten(append([_fb],[__f]))),
            _ft:apply('ev,flatten(append([_ft],[__f]))),
            if sign(_ft) = sign(_fb)
                then print("Expression must not have same sign at both endpoints")
                else (_side:0,
                      for i thru 10000 do
                          (_n:(_fb*_t-_ft*_b)/(_fb-_ft),
                           if abs(_t-_b) < _theaccuracy*abs(_t+_b)
                               then (i:10^6,fpprec:__digits,
                                     _retval:bfloat(_n))
                               else (_fn:at(__expr,__x = _n),
                                     _fn
                                      :apply('ev,
                                             flatten(append([_fn],[__f]))),
                                     if _fn*_ft > 0
                                         then (_t:_n,_ft:_fn,
                                               if _side = -1 then _fb:_fb/2,
                                               _side:-1) elseif _fb*_fn > 0
                                         then (_b:_n,_fb:_fn,
                                               if _side = 1 then _ft:_ft/2,
                                               _side:1)
                                         else (i:10^6,fpprec:__digits,
                                               _retval:bfloat(_n))))),_retval);

/* Problem 73 (line 2652) */
countvars(__e):=block(
          [inflag:true,_vars:[],_undupedvars:[],_retvals:[],_cnt,_i,_j],
          scanatoms(block([__z],
                          lambda([__z],
                                 if not numberp(__z)
                                      and not member(__z,
                                                     [%pi,%phi,%e,%i,'inf,
                                                      'minf])
                                     then _vars:cons(__z,_vars))),__e),
          _undupedvars:listify(setify(_vars)),
          for _i in _undupedvars do
              (_cnt:0,
               for _j in _vars do if is(_i = _j) = true then _cnt:_cnt+1,
               _retvals:cons([_i,_cnt],_retvals)),
          _retvals:sort(_retvals,
                        lambda([__z1,__z2],
                               if is(second(__z1) < second(__z2)) = true
                                   then true)));
/* Erroneous Result?:
countvars(__e):=block(
          [inflag:true,_vars:[],_undupedvars:[],_retvals:[],_cnt,_i,_j],
          scanatoms(block([__z],
                          lambda([__z],
                                 if not numberp(__z)
                                      and not member(__z,
                                                     [%pi,%phi,%e,%i,'inf,
                                                      'minf])
                                     then _vars:cons(__z,_vars))),__e),
          _undupedvars:listify(setify(_vars)),
          for _i in _undupedvars do
              (_cnt:0,
               for _j in _vars do if is(_i = _j) = true then _cnt:_cnt+1,
               _retvals:cons([_i,_cnt],_retvals)),
          _retvals:sort(_retvals,
                        lambda([__z1,__z2],
                               if is(second(__z1) < second(__z2)) = true
                                   then true))) */ 
/* Expected result: */
scanatoms(__f,__e):=block([inflag:true,_retval:true,_p,_done],
          if safe_op(__e) # false then (for _p in __e do scanatoms(__f,_p))
              elseif safe_op(__e) # false and length(args(__e)) > 0
              then (for _p in args(__e) do scanatoms(__f,_p))
              elseif mapatom(__e) then apply(__f,[__e]) else apply(__f,[__e]),
          _done);

/* Problem 74 (line 2702) */
scanex(__f,__e):=block([inflag:true,_p],
       if safe_op(__e) # false
           then (apply(__f,[__e]),
                 for _p in __e do
                     if safe_op(_p) # false
                         then (scanex(__f,_p),apply(__f,[_p]))
                         else apply(__f,[_p])) else apply(__f,[_p]));
/* Erroneous Result?:
scanex(__f,__e):=block([inflag:true,_p],
       if safe_op(__e) # false
           then (apply(__f,[__e]),
                 for _p in __e do
                     if safe_op(_p) # false
                         then (scanex(__f,_p),apply(__f,[_p]))
                         else apply(__f,[_p])) else apply(__f,[_p])) */ 
/* Expected result: */
max2iif(__e):=block([inflag:true,opsubst:true,_retval:0],
        _retval:subst('max = lambda([[_z]],apply('_listiifs1,_z)),__e));

/* Problem 75 (line 2721) */
_listiifs1([_z]):=block(
           [inflag:true,opsubst:true,_len:length(_z),_iifs:[],_retval:0],
           if length(_z) > 1
               then _retval:simp_iif(iif(first(_z) > second(_z),
                                         apply('_listiifs1,
                                               list_remove(_z,2,1)),
                                         apply('_listiifs1,rest(_z))))
               else first(_z));
/* Erroneous Result?:
_listiifs1([_z]):=block(
           [inflag:true,opsubst:true,_len:length(_z),_iifs:[],_retval:0],
           if length(_z) > 1
               then _retval:simp_iif(iif(first(_z) > second(_z),
                                         apply('_listiifs1,
                                               list_remove(_z,2,1)),
                                         apply('_listiifs1,rest(_z))))
               else first(_z)) */ 
/* Expected result: */
min2iif(__e):=block([inflag:true,opsubst:true,_retval:0],
        _retval:subst('min = lambda([[_z]],apply('_listiifs2,_z)),__e));

/* Problem 76 (line 2739) */
_listiifs2([_z]):=block(
           [inflag:true,opsubst:true,_len:length(_z),_iifs:[],_retval:0],
           if length(_z) > 1
               then _retval:simp_iif(iif(first(_z) < second(_z),
                                         apply('_listiifs2,
                                               list_remove(_z,2,1)),
                                         apply('_listiifs2,rest(_z))))
               else first(_z));
/* Erroneous Result?:
_listiifs2([_z]):=block(
           [inflag:true,opsubst:true,_len:length(_z),_iifs:[],_retval:0],
           if length(_z) > 1
               then _retval:simp_iif(iif(first(_z) < second(_z),
                                         apply('_listiifs2,
                                               list_remove(_z,2,1)),
                                         apply('_listiifs2,rest(_z))))
               else first(_z)) */ 
/* Expected result: */
maxmin2iif(__e):=max2iif(min2iif(__e));

